<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java反射入门</title>
      <link href="/2025/08/10/Java%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/"/>
      <url>/2025/08/10/Java%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在<code>spring</code>项目中，只需要写个<code>@Service</code>或者<code>@Component</code>，然后在别的地方用<code>@Autowired</code>声明一个接口变量，<code>Spring</code>就能返回给我们一个实现了该接口的具体对象。这是如何实现的呢？它不可能在编译时就知道加了注解的类与类之间的关系，所以只能是在程序启动<strong>运行时</strong>，Spring动态地发现了这些类，读取了他们的结构，然后创建对象。这背后的技术支撑又是什么？答案就是反射。</p><p>反射是Java提供的一种在<strong>程序运行时</strong></p><ul><li>检查&#x2F;获取类、接口、字段、方法、构造器等结构信息的能力。</li><li>操作&#x2F;调用对象、字段、方法的能力。</li></ul><p>它就像一面镜子，让程序在运行时“照见”自己的结构。</p><h2 id="反射的基石：Class对象"><a href="#反射的基石：Class对象" class="headerlink" title="反射的基石：Class对象"></a>反射的基石：<code>Class</code>对象</h2><p>编译器在编译 Java 源代码时会生成 <code>.class</code> 文件（字节码文件）。当 JVM 需要用到某个类时，它的类加载器会读取并解析对应的 <code>.class</code> 文件，在方法区（或元空间）构建该类的运行时数据结构，同时在堆内存中创建一个代表该类的 <strong><code>java.lang.Class</code> 对象</strong>。每个被加载的类在 JVM 中都有且只有一个对应的 <code>Class</code> 对象（在同一个类加载器命名空间内）。</p><p>这里的<code>Class</code>是一个类的名字，不要和<code>class</code>关键字搞混。</p><p>有三种方法获取<code>Class</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;me&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//法一：通过对象实例</span></span><br><span class="line">Class&lt; ? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; clazz1 = person.getClass();</span><br><span class="line"><span class="comment">//法二：自带属性（基本数据类型也有）</span></span><br><span class="line">Class&lt;Person&gt; clazz2 = Person.class;</span><br><span class="line"><span class="comment">//法三：Class类的静态方法 forName</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;org.myblog.reflection.Person&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下这三种方法泛型的使用：法一使用<code>Class&lt;? extends Person&gt; </code>因为<code>Class</code>对象是在运行时从<code>Person</code>实例获取的，而<code>Person</code>实例的具体类型只能在运行时创建和确定，编译阶段无法判断，所以使用通配符 ，又因为<code>person</code>可能是<code>Person</code>实例，也可能是<code>Person</code>的子类实例，所以最终写成<code>Class&lt; ? extends Person&gt;</code>；法二使用<code>Class&lt;Person&gt;</code>因为编译时已知具体类型；法三使用<code>Class&lt;?&gt;</code>因为通过字符串动态加载类，编译时无法确定具体类型，所以使用通配符。这三个 Class 对象都是同一个（上面也提到了，一个类唯一对应一个 Class 对象）。</p><p><strong>最常用、最灵活的是法三</strong></p><h2 id="反射的核心操作"><a href="#反射的核心操作" class="headerlink" title="反射的核心操作"></a>反射的核心操作</h2><p><code>Person</code>类具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">species</span> <span class="operator">=</span> <span class="string">&quot;Human&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;,I&#x27;m &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">celebrateBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        age++;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is now &quot;</span> + age + <span class="string">&quot; years old!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">describeSpecies</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;We are all &quot;</span> + species);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.example.myblog.reflection.Person&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;类名：&quot;</span> + clazz.getName());</span><br><span class="line">System.out.println(<span class="string">&quot;包名：&quot;</span> + clazz.getPackage().getName());</span><br><span class="line">System.out.println(<span class="string">&quot;父类：&quot;</span> + clazz.getSuperclass());</span><br><span class="line">System.out.println(<span class="string">&quot;接口：&quot;</span> + Arrays.toString(clazz.getInterfaces()));</span><br><span class="line">System.out.println(<span class="string">&quot;修饰符：&quot;</span> + Modifier.toString(clazz.getModifiers()));</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名：org.example.myblog.reflection.Person</span><br><span class="line">包名：org.example.myblog.reflection</span><br><span class="line">父类：class java.lang.Object</span><br><span class="line">接口：[]</span><br><span class="line">修饰符：public</span><br></pre></td></tr></table></figure><h3 id="操作字段"><a href="#操作字段" class="headerlink" title="操作字段"></a>操作字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;操作字段+++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : allFields) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;- &quot;</span> + Modifier.toString(f.getModifiers()) + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    f.getType().getSimpleName() + <span class="string">&quot; &quot;</span> + f.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;me&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//访问public字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(nameField.get(me));</span><br><span class="line"><span class="comment">//访问private字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(ageField.get(me));</span><br><span class="line">ageField.set(me, <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改后年龄: &quot;</span> + ageField.get(me));</span><br><span class="line"><span class="comment">//访问static字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">speciesField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;species&quot;</span>);</span><br><span class="line">System.out.println(speciesField.get(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">public</span> String name</span><br><span class="line">- <span class="keyword">private</span> <span class="type">int</span> age</span><br><span class="line">- <span class="keyword">public</span> <span class="keyword">static</span> String species</span><br><span class="line">me</span><br><span class="line"><span class="number">20</span></span><br><span class="line">修改后年龄: <span class="number">18</span></span><br><span class="line">Human</span><br></pre></td></tr></table></figure><p>说明几点：</p><ol><li><p><code>getDeclaredFields()</code>是获取所有字段，并返回一个数组，<code>getField</code>则是根据参数返回指定字段，返回的是<code>Field</code>实例。</p></li><li><p>最后一行<code>speciesField.get(null)</code>传入参数<code>null</code>，因为静态字段是属于这个类的，当然也可以传入对象<code>me</code>。</p></li><li><p><code>ageField.setAccessible(true);</code>这个方法传入参数<code>true</code>表示<strong>屏蔽Java语言的访问检查</strong>。看下面这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : allFields) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> Modifier.isStatic(f.getModifiers()) ? <span class="literal">null</span> : me;</span><br><span class="line">            System.out.println(<span class="string">&quot;  可访问性: &quot;</span> + f.canAccess(target));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> Modifier.isStatic(f.getModifiers()) ? <span class="literal">null</span> : me;</span><br><span class="line">    System.out.println(<span class="string">&quot;  可访问性: &quot;</span> + f.canAccess(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- public String name</span><br><span class="line">  可访问性: true</span><br><span class="line">- private int age</span><br><span class="line">  可访问性: false</span><br><span class="line">- public static String species</span><br><span class="line">  可访问性: true</span><br></pre></td></tr></table></figure><p>输出如上，<code>age</code>是不可访问的，在<code>setAccessible(true)</code>后可以访问并修改。否则会报错。</p></li><li><p>如果想要访问<code>private</code>或其他非<code>public</code>字段，必须使用<code>getDeclaredField()</code>，<strong>注意里面有<code>Declared</code>，这个规律同样适用后面的<code>Method</code>和<code>Constructor</code>。</strong></p></li></ol><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;\n==== 方法操作 ====&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">Dong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dong&quot;</span>, <span class="number">18</span>);</span><br><span class="line">Method[] allMethods = clazz.getDeclaredMethods();</span><br><span class="line">System.out.println(<span class="string">&quot;所有方法:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Method m : allMethods) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;- &quot;</span> + m.getName() + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用public方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">greetMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;greet&quot;</span>, String.class);</span><br><span class="line">greetMethod.invoke(Dong, <span class="string">&quot;李明&quot;</span>);</span><br><span class="line"><span class="comment">// 调用private方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">birthdayMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;celebrateBirthday&quot;</span>);</span><br><span class="line">birthdayMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">birthdayMethod.invoke(Dong);</span><br><span class="line">System.out.println(<span class="string">&quot;新年龄: &quot;</span> + ageField.get(Dong)); <span class="comment">// 验证年龄增加</span></span><br><span class="line"><span class="comment">// 调用static方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">speciesMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;describeSpecies&quot;</span>);</span><br><span class="line">speciesMethod.invoke(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">所有方法:</span><br><span class="line">- celebrateBirthday()</span><br><span class="line">- describeSpecies()</span><br><span class="line">- greet()</span><br><span class="line">Hello 李明,I&#x27;m dong</span><br><span class="line">dong is now 19 years old!</span><br><span class="line">新年龄: 19</span><br><span class="line">We are all Human</span><br></pre></td></tr></table></figure><p>其实和操作字段有很多相似之处，这里说一下<code>invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">greetMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;greet&quot;</span>, String.class);</span><br><span class="line">greetMethod.invoke(Dong, <span class="string">&quot;李明&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>getMethod</code>方法有两个参数，一个是方法名称，一个是参数的<code>class</code>对象</p><p><code>greetMethod</code>方法同样有两个参数，一个是对象实例（如果是静态方法则传入<code>null</code>），一个是传递的参数。这两个方法的参数个数不是固定的(其实是个数组)，这取决于目标方法的参数个数。</p><h3 id="操作构造器"><a href="#操作构造器" class="headerlink" title="操作构造器"></a>操作构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">System.out.println(<span class="string">&quot;所有构造器:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; c : constructors) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;参数数量: &quot;</span> + c.getParameterCount());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用public无参构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; emptyConstructor = clazz.getConstructor();</span><br><span class="line"><span class="type">Person</span> <span class="variable">unknown</span> <span class="operator">=</span> (Person) emptyConstructor.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;无参构造创建: &quot;</span> + unknown.name);</span><br><span class="line"><span class="comment">// 使用public带参构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; paramConstructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Person</span> <span class="variable">sarah</span> <span class="operator">=</span> (Person) paramConstructor.newInstance(<span class="string">&quot;Sarah&quot;</span>, <span class="number">28</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;带参构造创建: &quot;</span> + sarah.name + <span class="string">&quot;, &quot;</span> + ageField.get(sarah));</span><br><span class="line"><span class="comment">// 使用private构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; privateConstructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">privateConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">secret</span> <span class="operator">=</span> (Person) privateConstructor.newInstance(<span class="string">&quot;Secret&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;私有构造创建: &quot;</span> + secret.name + <span class="string">&quot;, &quot;</span> + ageField.get(secret));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所有构造器:</span><br><span class="line">参数数量: 1</span><br><span class="line">参数数量: 2</span><br><span class="line">参数数量: 0</span><br><span class="line">无参构造创建: Unknown</span><br><span class="line">带参构造创建: Sarah, 28</span><br><span class="line">私有构造创建: Secret, 18</span><br></pre></td></tr></table></figure><p>经过前面叙述，这里的相关方法也是很好理解，<code>getConstructor</code>方法的参数取决于你拿到的构造器的参数（其实也是个数组）。</p><p><code>newInstance()</code>方法可以根据你拿到的构造器来创建该构造器所在类的实例，参数同上理解。例子中是直接强转类型了，如果<code>clazz</code>是用法二得到的，也可以使用<code>cast</code>方法进行类型转换。一般来说这个方法创建的实例用<code>Object</code>来接收，因为创建的对象是在运行时动态生成的，编译阶段无法知道。<strong>建议使用反射直接调用和操作对象的方法和字段，而不是先进行类型转换，毕竟如果在编写阶段已经明确了要转换的类型，那么直接显示地调用更合适，而不必依赖于反射。反射的真正价值在于处理编译时未知的类型，从而编写更具有通用性的代码。</strong></p><p>示例里用<code>Constructor&lt;?&gt;</code>接收<code>clazz.getConstructor()</code>创建的实例是因为<code>clazz</code>的创建就使用的是通配符。如果在创建时指定类，那便可以指定泛型参数，相当于构造器就知道自己要构造的对象是什么类型了。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>上述内容只是反射部分的冰山一角，我已经尽我所能把这“一角”讲述清楚。</p><p>反射很强，它能提供运行时动态操作类和对象的能力，是很多框架的基石，但同时它也带来了很多问题，性能开销大、代码可读性差等等。在日常开发中，程序员还是会优先选择直接调用、接口、设计模式等更清晰、高效的方式。</p><p>有机会我也会更新一个与反射有关的实战案例，欢迎收藏我的网站。</p><p>参考文章：</p><ul><li><p><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">大白话说Java反射：入门、使用、原理 - 陈树义 - 博客园</a></p></li><li><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遇到的奇葩BUG</title>
      <link href="/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/"/>
      <url>/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/</url>
      
        <content type="html"><![CDATA[<p>此篇博客记录我学习过程中遇到的奇葩BUG</p><h2 id="SpringBoot项目启动失败"><a href="#SpringBoot项目启动失败" class="headerlink" title="SpringBoot项目启动失败"></a><code>SpringBoot</code>项目启动失败</h2><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250801212248493.png" alt="image-20250801212248493"></p><p>如上图，<code>SpringBoot</code>项目启动失败。</p><p>虽然说是端口占用，但我执行相关命令后没有任何输出，修改启动端口不行，尝试了很多办法都未成功，那只好使出我的终极大招：重启idea。还是不行。幸好我还有终极终极大招：重启电脑。嘿，你猜怎么着，成了！🤣</p>]]></content>
      
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识序列化与反序列化</title>
      <link href="/2025/07/07/%E5%88%9D%E8%AF%86%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/07/07/%E5%88%9D%E8%AF%86%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><p>序列化，人话讲就是将对象转换为字节序列（也可以是JSON、XML等文本格式），反序列化就是把这个过程倒置。</p><p>下面是维基百科关于序列化的介绍</p><blockquote><p><strong>序列化</strong>（serialization）在<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">计算机科学</a>的资料处理中，是指将<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>或<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%B8)">对象</a>状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%BB%84">字节</a>的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是<strong>反序列化</strong>（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>对于Java这种面向对象的编程语言来说，是对实例化后的对象进行序列化，而对于C++这种半面向对象的编程语言来说，序列化的目标不仅有对象（class）还有数据结构（struct）</p><h2 id="序列化的使用场景"><a href="#序列化的使用场景" class="headerlink" title="序列化的使用场景"></a>序列化的使用场景</h2><ol><li><p>数据存储：比如序列化可以将存储在 JVM 堆区中的对象转换成字节序列，从而实现持久化。</p></li><li><p>网络通信：将对象转换为字节序列方便其在网络中进行传递和接收。</p></li></ol><h2 id="使用Java实现序列化"><a href="#使用Java实现序列化" class="headerlink" title="使用Java实现序列化"></a>使用Java实现序列化</h2><p>以 JDK 自带序列化方法为例，实现<code>java.io.Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        cat.setAge(<span class="number">2</span>);</span><br><span class="line">        cat.setBirth(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//使用ObjectOutputStream将cat对象序列化并存入test1.txt文件中</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream)) &#123;</span><br><span class="line">            objectOutputStream.writeObject(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">deserializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用ObjectInputStream对test.txt文件读取并反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream)) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) objectInputStream.readObject();</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=2, name=tom, birth=Fri Jul 04 21:37:13 CST 2035)</span><br></pre></td></tr></table></figure><p>接下来让我们走进<code>Serializable</code>的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错，<code>Serializable</code>接口中没有任何方法和字段，它的作用仅仅是告诉JVM：实现该接口的类可以被序列化，</p><p>其实除了实现<code>Serializable</code>接口外，还有一个选择就是实现<code>Externalizable</code>接口（该接口是<code>Serializable</code>的子接口），不过需要重写两个方法，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(birth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        birth = (Date) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化代码一样，最终结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=0, name=tom, birth=Fri Jul 04 21:43:23 CST 2025)</span><br></pre></td></tr></table></figure><p><code>writeExternal</code>和<code>readExternal</code>可以自定义哪些字段需要序列化，我这个例子中就没有对<code>age</code>进行操作，在反序列化后它被赋初值0。需要注意的是</p><blockquote><p>The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</p></blockquote><p>翻译过来意思就是这两个方法应该用相同的顺序和相同的类型对字段进行读写，相同的顺序容易理解，相同的类型意思就是在<code>readExternal</code>中强转的目标类型必须和<code>writeExternal</code>原类型保持一致。在实现<code>Externalizable</code>接口时，还有一点需要注意的是序列化对象中必须提供无参构造，以Cat类为例,当我加入一个有参构造覆盖默认无参构造后，序列化正常运行，反序列化出现报错</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250705112136780.png" alt="image-20250705112136780"></p><p><strong>关于序列化有几点需要注意：</strong></p><ol><li><p>只有实现该接口的类才可以被序列化。</p></li><li><p>可序列化类的所有子类是可以被序列化的。不可序列化类的子类型可以被序列化。</p></li><li><p>如果不想对某个变量序列化，可以用<code>transient</code>关键字修饰，它只能修饰变量，不能修饰类和方法。<code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</p></li><li><p>序列化运行时会为每个可序列化类分配一个版本号<code>serialVersionUID</code>该版本号在序列化机制中用于验证类的版本是否一致，如果反序列化时的UID和原来序列化的UID不同，则会抛出<code>InvalidClassException</code>。</p><p>这个字段可以手动显示声明，也可以自动生成。如果显示声明，这个字段必须是<code>static</code> <code>final</code>且类型为<code>long</code>的。如果该字段未被显示声明，JVM会根据该类的结构自动生成一个<code>serialVersionUID</code>，枚举类的<code>serialVersionUID</code>会被定义为0L。</p><p>官方强烈建议除了枚举类型以外的所有可序列化类显示声明<code>serialVersionUID</code>值，因为生成算法对类的细节非常敏感（如方法、字段等的变化都会导致<code>serialVersionUID</code>改变），从而导致兼容性问题。显式设置 <code>serialVersionUID </code>可以确保在类发生非兼容更改时由开发者主动决定是否更新 UID，而不是因为类结构微小变化而导致反序列化失败。同时官方建议使用private来声明<code>serialVersionUID</code>，因为该字段不会被子类继承使用，因此没必要设置为<code>public</code>或<code>protected</code>。下面是一个完整的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serial</span><span class="comment">//Java14后建议添加</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>这时小明举手说：老师老师，如果<code>serialVersionUID</code>被<code>static</code>修饰，那他就属于这个类，而不属于实例化后的对象了，那怎么将这个字段序列化呢？老师说：好问题，<del>我也不知道。</del> 序列化保存的是对象的状态，也就是实例变量的值，然而<code>serialVersionUID</code>是一个特例，它本身确实不作为对象状态被序列化，但它的值被序列化机制特殊处理了。屏幕前的你明白了吗，反正我还是有点糊涂，我觉得把它视为一个特例就好了，要真正弄懂怕是要搞明白JVM，那要很久以后了。</p></li></ol><h2 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h2><p>这里我推荐观看<a href="https://5i1encee.top/">5i1encee</a>的相关博客，关于反序列化漏洞我简要介绍一下。</p><p>当攻击者通过构造恶意输入，让反序列化产生非预期的的对象，那么在反序列化这个过程中就可能执行恶意代码。已经有多个版本的库或框架被发现存在反序列化漏洞，如<code>Apache Commons Collections</code> 。借用<a href="https://www.zhihu.com/question/37562657/answer/1916596031">一位大哥</a>的例子来简单说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerabilityTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>MyObject</code>这个类中，自定义了<code>readObject</code>这个方法，相当于可以自己决定对哪些字段反序列化。在<code>readObject</code>这个方法里通过调用<code>defaultReadObject</code>来实现默认的反序列化机制。之后执行了名为<code>calc</code>的系统命令，这是<code>Windows</code>下启动计算器的命令。当我进行反序列化操作时，电脑上的计算器也随之启动。实际上，Java 反序列化漏洞产生的原因大多数是因为反序列化时没有进行校验，或者有些校验使用黑名单方式又被绕过，最终使得包含恶意代码的序列化对象在服务器端被反序列化执行。</p><h2 id="其他序列化协议"><a href="#其他序列化协议" class="headerlink" title="其他序列化协议"></a>其他序列化协议</h2><p>上述有关代码的举例均是 JDK 自带的序列化协议，但它在开发中很少被使用，主要原因如下：</p><ol><li>严重的安全风险：正如例子中提到的<code>readObject</code>方法，攻击者可构造恶意序列化数据触发任意代码执行</li><li>跨语言兼容性差：该协议序列化后的二进制数据只能被 Java 程序识别，无法与其他语言交互，多语言协作困难。</li><li>性能低下：序列化后的二进制数据体积远大于 JSON 或其他二进制协议。同时因为需要反射和递归处理对象图，导致速度较慢。</li></ol><p>常用的序列化协议有Hessian、Kryo、 Protobuf、 ProtoStuff 等，这些都是基于二进制的序列化协议。SpringBoot 项目中也可以集成 Jackson、Fastjson 等将对象序列化为JSON格式的库。</p><p>第一篇博客先写到这里，个人理解难免有偏差，欢迎评论区指正。我以后也会继续更新，欢迎收藏<a href="https://withdong02.top/">我的网站</a>。</p><p>参考文章：</p><ul><li><a href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解 | JavaGuide</a></li><li><a href="https://www.zhihu.com/question/37562657/answer/1916596031">(6 封私信 &#x2F; 70 条消息) Java反序列化安全漏洞怎么回事? - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
