<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>遇到的奇葩BUG</title>
      <link href="/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/"/>
      <url>/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/</url>
      
        <content type="html"><![CDATA[<p>此篇博客记录我学习过程中遇到的奇葩BUG</p><h2 id="SpringBoot项目启动失败"><a href="#SpringBoot项目启动失败" class="headerlink" title="SpringBoot项目启动失败"></a><code>SpringBoot</code>项目启动失败</h2><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250801212248493.png" alt="image-20250801212248493"></p><p>如上图，<code>SpringBoot</code>项目启动失败。</p><p>虽然说是端口占用，但我执行相关命令后没有任何输出，修改启动端口不行，尝试了很多办法都未成功，那只好使出我的终极大招：重启idea。还是不行。幸好我还有终极终极大招：重启电脑。嘿，你猜怎么着，成了！🤣</p>]]></content>
      
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识序列化与反序列化</title>
      <link href="/2025/07/07/%E5%88%9D%E8%AF%86%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/07/07/%E5%88%9D%E8%AF%86%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><p>序列化，人话讲就是将对象转换为字节序列（也可以是JSON、XML等文本格式），反序列化就是把这个过程倒置。</p><p>下面是维基百科关于序列化的介绍</p><blockquote><p><strong>序列化</strong>（serialization）在<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">计算机科学</a>的资料处理中，是指将<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>或<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%B8)">对象</a>状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%BB%84">字节</a>的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是<strong>反序列化</strong>（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>对于Java这种面向对象的编程语言来说，是对实例化后的对象进行序列化，而对于C++这种半面向对象的编程语言来说，序列化的目标不仅有对象（class）还有数据结构（struct）</p><h2 id="序列化的使用场景"><a href="#序列化的使用场景" class="headerlink" title="序列化的使用场景"></a>序列化的使用场景</h2><ol><li><p>数据存储：比如序列化可以将存储在 JVM 堆区中的对象转换成字节序列，从而实现持久化。</p></li><li><p>网络通信：将对象转换为字节序列方便其在网络中进行传递和接收。</p></li></ol><h2 id="使用Java实现序列化"><a href="#使用Java实现序列化" class="headerlink" title="使用Java实现序列化"></a>使用Java实现序列化</h2><p>以 JDK 自带序列化方法为例，实现<code>java.io.Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        cat.setAge(<span class="number">2</span>);</span><br><span class="line">        cat.setBirth(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//使用ObjectOutputStream将cat对象序列化并存入test1.txt文件中</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream)) &#123;</span><br><span class="line">            objectOutputStream.writeObject(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">deserializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用ObjectInputStream对test.txt文件读取并反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream)) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) objectInputStream.readObject();</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=2, name=tom, birth=Fri Jul 04 21:37:13 CST 2035)</span><br></pre></td></tr></table></figure><p>接下来让我们走进<code>Serializable</code>的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错，<code>Serializable</code>接口中没有任何方法和字段，它的作用仅仅是告诉JVM：实现该接口的类可以被序列化，</p><p>其实除了实现<code>Serializable</code>接口外，还有一个选择就是实现<code>Externalizable</code>接口（该接口是<code>Serializable</code>的子接口），不过需要重写两个方法，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(birth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        birth = (Date) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化代码一样，最终结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=0, name=tom, birth=Fri Jul 04 21:43:23 CST 2025)</span><br></pre></td></tr></table></figure><p><code>writeExternal</code>和<code>readExternal</code>可以自定义哪些字段需要序列化，我这个例子中就没有对<code>age</code>进行操作，在反序列化后它被赋初值0。需要注意的是</p><blockquote><p>The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</p></blockquote><p>翻译过来意思就是这两个方法应该用相同的顺序和相同的类型对字段进行读写，相同的顺序容易理解，相同的类型意思就是在<code>readExternal</code>中强转的目标类型必须和<code>writeExternal</code>原类型保持一致。在实现<code>Externalizable</code>接口时，还有一点需要注意的是序列化对象中必须提供无参构造，以Cat类为例,当我加入一个有参构造覆盖默认无参构造后，序列化正常运行，反序列化出现报错</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250705112136780.png" alt="image-20250705112136780"></p><p><strong>关于序列化有几点需要注意：</strong></p><ol><li><p>只有实现该接口的类才可以被序列化。</p></li><li><p>可序列化类的所有子类是可以被序列化的。不可序列化类的子类型可以被序列化。</p></li><li><p>如果不想对某个变量序列化，可以用<code>transient</code>关键字修饰，它只能修饰变量，不能修饰类和方法。<code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</p></li><li><p>序列化运行时会为每个可序列化类分配一个版本号<code>serialVersionUID</code>该版本号在序列化机制中用于验证类的版本是否一致，如果反序列化时的UID和原来序列化的UID不同，则会抛出<code>InvalidClassException</code>。</p><p>这个字段可以手动显示声明，也可以自动生成。如果显示声明，这个字段必须是<code>static</code> <code>final</code>且类型为<code>long</code>的。如果该字段未被显示声明，JVM会根据该类的结构自动生成一个<code>serialVersionUID</code>，枚举类的<code>serialVersionUID</code>会被定义为0L。</p><p>官方强烈建议除了枚举类型以外的所有可序列化类显示声明<code>serialVersionUID</code>值，因为生成算法对类的细节非常敏感（如方法、字段等的变化都会导致<code>serialVersionUID</code>改变），从而导致兼容性问题。显式设置 <code>serialVersionUID </code>可以确保在类发生非兼容更改时由开发者主动决定是否更新 UID，而不是因为类结构微小变化而导致反序列化失败。同时官方建议使用private来声明<code>serialVersionUID</code>，因为该字段不会被子类继承使用，因此没必要设置为<code>public</code>或<code>protected</code>。下面是一个完整的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serial</span><span class="comment">//Java14后建议添加</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>这时小明举手说：老师老师，如果<code>serialVersionUID</code>被<code>static</code>修饰，那他就属于这个类，而不属于实例化后的对象了，那怎么将这个字段序列化呢？老师说：好问题，<del>我也不知道。</del> 序列化保存的是对象的状态，也就是实例变量的值，然而<code>serialVersionUID</code>是一个特例，它本身确实不作为对象状态被序列化，但它的值被序列化机制特殊处理了。屏幕前的你明白了吗，反正我还是有点糊涂，我觉得把它视为一个特例就好了，要真正弄懂怕是要搞明白JVM，那要很久以后了。</p></li></ol><h2 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h2><p>这里我推荐观看<a href="https://5i1encee.top/">5i1encee</a>的相关博客，关于反序列化漏洞我简要介绍一下。</p><p>当攻击者通过构造恶意输入，让反序列化产生非预期的的对象，那么在反序列化这个过程中就可能执行恶意代码。已经有多个版本的库或框架被发现存在反序列化漏洞，如<code>Apache Commons Collections</code> 。借用<a href="https://www.zhihu.com/question/37562657/answer/1916596031">一位大哥</a>的例子来简单说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerabilityTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>MyObject</code>这个类中，自定义了<code>readObject</code>这个方法，相当于可以自己决定对哪些字段反序列化。在<code>readObject</code>这个方法里通过调用<code>defaultReadObject</code>来实现默认的反序列化机制。之后执行了名为<code>calc</code>的系统命令，这是<code>Windows</code>下启动计算器的命令。当我进行反序列化操作时，电脑上的计算器也随之启动。实际上，Java 反序列化漏洞产生的原因大多数是因为反序列化时没有进行校验，或者有些校验使用黑名单方式又被绕过，最终使得包含恶意代码的序列化对象在服务器端被反序列化执行。</p><h2 id="其他序列化协议"><a href="#其他序列化协议" class="headerlink" title="其他序列化协议"></a>其他序列化协议</h2><p>上述有关代码的举例均是 JDK 自带的序列化协议，但它在开发中很少被使用，主要原因如下：</p><ol><li>严重的安全风险：正如例子中提到的<code>readObject</code>方法，攻击者可构造恶意序列化数据触发任意代码执行</li><li>跨语言兼容性差：该协议序列化后的二进制数据只能被 Java 程序识别，无法与其他语言交互，多语言协作困难。</li><li>性能低下：序列化后的二进制数据体积远大于 JSON 或其他二进制协议。同时因为需要反射和递归处理对象图，导致速度较慢。</li></ol><p>常用的序列化协议有Hessian、Kryo、 Protobuf、 ProtoStuff 等，这些都是基于二进制的序列化协议。SpringBoot 项目中也可以集成 Jackson、Fastjson 等将对象序列化为JSON格式的库。</p><p>第一篇博客先写到这里，个人理解难免有偏差，欢迎评论区指正。我以后也会继续更新，欢迎收藏<a href="https://withdong02.top/">我的网站</a>。</p><p>参考文章：</p><ol><li><a href="https://javaguide.cn/java/basis/serialization.html">https://javaguide.cn/java/basis/serialization.html</a></li><li><a href="https://www.zhihu.com/question/37562657/answer/1916596031">https://www.zhihu.com/question/37562657/answer/1916596031</a></li><li><a href="http://www.deepseek.com/">www.deepseek.com</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
