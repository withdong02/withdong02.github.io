<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣题目分享</title>
      <link href="/2026/02/15/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/"/>
      <url>/2026/02/15/%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>一切源于一道题目：<a href="https://leetcode.cn/problems/string-to-integer-atoi/description/">8. 字符串转换整数 (atoi) - 力扣（LeetCode）</a></p><p>考虑这样一个问题：给你一个数字字符串，如何在32位环境下安全的处理可能超过<code>[-2^31, 2^31 - 1]</code>范围的数字，不能使用64位变量临时存储。</p><p>因为我熟悉Java， 所以下面提到的数据类型都为 Java 中的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE = <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span> = <span class="number">2147483647</span>;</span><br><span class="line">Integer.MIN_VALUE = -<span class="number">2</span>^<span class="number">31</span> = -<span class="number">2147483648</span>;</span><br></pre></td></tr></table></figure><p>首先题目说不能使用64位变量，所以 Long 类型不能使用，那就一步一步累加，具体思路就是设置两个变量 <code>digit, res</code>，从头到尾遍历字符串每一位，同时计算 <code>res = res * 10 + digit</code>。但这样的话，累加过程中 <code>res</code> 可能会无征兆直接溢出，程序直接抛异常。那怎么办，介绍一下从 <a href="https://leetcode.cn/problems/string-to-integer-atoi/solutions/2361399/8-zi-fu-chuan-zhuan-huan-zheng-shu-atoiq-a2e8/">K神题解</a> 里学来的方法。</p><p>整体思路也是一步一步累加，但提前预判溢出。</p><p>这里有个核心变量 <code>bndry = 2^31 / 10 = 214748364</code>，，它是32位有符号整数最大值去掉最后一位的结果。</p><p>在执行 <code>res = res * 10 + digit</code> 之前，先检查 <code>res</code> 与 <code>bndry</code> 的关系，有下面两种溢出的可能。</p><ul class="lvl-0"><li class="lvl-2"><p>情况一：<code>res &gt; bndry</code> ，意味着 <code>res</code> 乘10后，即使加上最小的数字0，结果也会超过 2147483647，溢出。</p></li><li class="lvl-2"><p>情况二：<code>res == bndry</code>，此时是否溢出取决于要累加的数字  <code>digit</code>。</p><ul class="lvl-2"><li class="lvl-6">如果 <code>digit &lt;= 7</code>，此时正数负数都不会溢出，但等于七对正数来说已经达到最大值。</li><li class="lvl-6">如果 <code>digit = 8</code>，拼接后值为 2147483648，比 <code>Integer.MAX_VALUE</code> 大 1，而负数即 -2147483648 还未溢出。</li><li class="lvl-6">如果 <code>digit &gt; 8</code>，正数负数都溢出。</li></ul></li></ul><p>思路还是很清晰的，在下一位拼接前进行判断可以很好的避开溢出问题。下面看一下题解代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.trim().toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (chars.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bndry</span> <span class="operator">=</span> Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; chars.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[j] &lt; <span class="string">&#x27;0&#x27;</span> || chars[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; bndry || (res == bndry &amp;&amp; chars[j] &gt; <span class="string">&#x27;7&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + chars[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断条件 <code>chars[j] &gt; '7'</code> 对正数和负数同样有效。当 <code>digit = 8</code> 时，正数已溢出，返回 <code>Integer.MAX_VALUE</code>；负数虽然未溢出，但此时返回 <code>Integer.MIN_VALUE</code> 恰好就是正确结果。</p><p>其实除了下面的溢出判断，K神对首字符的处理也很妙，大佬不愧是大佬。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合源码阅读</title>
      <link href="/2026/01/26/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2026/01/26/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>先附上二哥网站上关于集合框架的结构图</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20260126165155214.png" alt="image-20260126165155214"></p><p><strong>版本为JDK21</strong></p><h2 id="ArrayList-扩容机制">ArrayList 扩容机制</h2><p>先介绍一下 ArrayList 中的关键变量：</p><ul class="lvl-0"><li class="lvl-2"><p><code>transient Object[] elementData</code> 底层用来存储元素的数组</p></li><li class="lvl-2"><p><code>private int size;</code> 表示集合中元素的实际数量</p></li><li class="lvl-2"><p><code>private static final int DEFAULT_CAPACITY = 10;</code> 默认初始容量</p></li><li class="lvl-2"><p><code>private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</code> 当用户调用 <code>new ArrayList(0)</code> 时，elementData 会引用该数组。</p></li><li class="lvl-2"><p><code>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code> 当用户调用默认构造参数时会引用该数组。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                                                  minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                                                  oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是有关扩容的源代码。</p><p>添加元素（比如调用 add(E e) 方法）时会进行判断 <code>if (s == elementData.length) elementData = grow()</code> 如果当前元素数量（size）等于数组容量（elementData.length），则会触发扩容机制。</p><p>在无参 grow 方法计算 size + 1，也就是有参 grow 函数的参数 minCapacity（所需最小容量）。</p><p>当数组通过默认构造实现，且从未添加元素（即 <code>oldCapacity == 0 &amp;&amp; elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>）时，会进入 else 分支，创建一个新数组，数组长度为10。</p><p>如果进入 if 分支，会计算新容量，newLength 方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会比较 minGrowth 和 prefGrowth，一个表示最小增长量，一个表示首选增长量，在大多数情况下后者更大，所以一般情况下会说1.5倍扩容。计算得到 prefLength ，如果该值超过了最大容量限制，则调用 hugeLength 方法，这里不再描述。</p><p>得到 newCapacity 后，创建新数组并拷贝原数组数据，返回新数组，扩容结束。</p><p>有时创建集合时，可以在构造函数中指定数组大小，避免频繁的扩容。</p><h2 id="HashMap-的-put-方法">HashMap 的 put 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，在 put 方法里先将 key 传入 hash 函数（在该函数里，获得 key 的哈希值后进一步对其位运算和异或运算，扰乱哈希值，减少哈希冲突），然后将得到的值与其他值传入 putVal 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>第二步，如果数组为空，进行第一次数组扩容。同时计算索引位置，如果当前位置为空，则直接将键值对插入该位置。这里有个小技巧，当 n 是2的幂次方时 <code>hash &amp; (n - 1)</code> 在效果上和 <code>hash % n</code> 是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>第三步，如果当前位置不为空，进入 else 分支。此时 p 指向当前桶位 <code>tab[i]</code> 的第一个节点。</p><p>全方位比较传入对象和变量 p 的属性：先比较哈希值，如果 hash 值不同，key 肯定不同。然后比较引用或值，一个判断内存地址是否相同，一个判断内容是否相同。如果条件都满足，证明找到了完全相同的 key ，将变量 e 指向 p。</p><p>如果进入 elseif 分支，会判断是否为红黑树节点，如果第一个节点不匹配，且该节点为 TreeNode 类型，说明该桶已树化，调用其他方法将新节点插入到红黑树中，在该方法中查找 key，找到则返回对应节点，找不到返回 null。</p><p>如果进入 else 分支，就是循环遍历链表，如果遍历到尾部也没找到，在尾部插入新节点，并判断是否需要树化。如果中途找到，则停止遍历。变量 e 指向找到的节点。</p><p>到这里 e 会有两种情况，如果 <code>e != null</code>，说明链表或红黑树中找到了已存在的 key，用新 value 覆盖旧 value，然后返回旧值。如果 <code>e == null</code>，说明没有找到，并成功在链表或红黑树中插入了新节点。</p><p>最后，根据 size 大小判断是否需要再次扩容。</p><p>整体思路是<strong>先查后改</strong>，查完之后变量 e 指向了需要更新的旧节点。</p><h2 id="HashMap-传参初始化">HashMap 传参初始化</h2><p>先说结论，如果传的是 17，HashMap 会将容量调整到大于等于 17 的最小的 2 的幂次方，如果不传参默认值是 16。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关代码如图，函数调用从上到下，最关键的是 tableSizeFor 方法。</p><p>第一步先将 cap 减一，这是为了处理 cap 本身就是 2 的幂次方的情况。</p><p>第二步进入 <code>numberOfLeadingZeros</code> 方法，该方法返回从最高位开始连续的 0 的个数，比如传入 15，返回 28（二进制表示共 32 位）。</p><p>第三步将 -1 无符号右移前导零的个数。-1 的二进制表示位 32 个 1（补码），无符号右移高位补 0。</p><p>第四步进行三元运算符判断。如果右移 32 位的话，先对 32 取模，比如 -1 右移 32 位还是 -1，因为 32 取模后为 0，相当于没有右移。</p><p>举个例子，当 cap 为 18 时，二进制表示为<code>0000 0000 0000 0000 0000 0000 0001 0010</code>，减一后为<code>0000 0000 0000 0000 0000 0000 0001 0001</code>，前导 0 有27个，所以将 -1 的二进制表示右移 27 个，得到<code>0000 0000 0000 0000 0000 0000 0001 1111</code>，十进制表示为 31，最后加 1 为 32。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来解释这段神奇的源码：把负数和 0 的情况排除后，先假设最高位在 31 位，如果 <code>i &gt;= 1 &lt;&lt; 16</code>，意思就是 i 大于等于 2 的 16 次方，说明最高位 1 一定在前 16 位中，这时 n 减 16，i 右移 16 位，这个操作相当于把 i 的低十六位丢弃，因为都是 0，然后将高 16 位移到低 16 位处理，如果 i 不大于等于 2 的 16 次方，就说明最高位 1 在后十六位，不做处理。接下来处理类似，在剩下的 16 位中，如果高 8 位满足条件，说明最高位 1 在这高 8 位中。n 减去 8，i 右移 8 位。</p><p>处理到最后， i 的值最多剩下 2 位，分别是 <code>00 01 10 11</code>，<code>n - (i &gt;&gt;&gt; 1)</code> 实际上是在判断剩下 2 位中最高位 1 的位置。整体思想类似<strong>二分查找</strong>。</p><p>这个方法上有 <code>@IntrinsicCandidate</code> 注解，表明会使用专门的 CPU 指令来代替这段代码，从而获得极高的执行速度。</p><h2 id="HashMap-resize-扩容方法">HashMap resize 扩容方法</h2><p>常见的执行 resize 方法的有两种情况：第一次 put 时的初始化扩容；元素数量超过阈值时的扩容。</p><p>先贴一下完整的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说前面的条件判断：</p><p>第一种情况：正常扩容。此时 <code>oldCap &gt; 0</code>，说明是因为元素过多触发了扩容。如果容量已达上限，将阈值设为 <code>Integer.MAX_VALUE</code>，这样就不会触发扩容了，直接返回旧数组；否则进入 elseif 分支（其实这个分支的条件我不理解），容量和阈值都翻倍。</p><p>第二种情况：带参构造初始化，此时 <code>oldCap == 0 &amp;&amp; oldThr &gt; 0</code>，初始容量设置为旧的 threshold。从上面的构造器源码可以看出，如果带参构造，loadFactor 和 threshold 将被赋值，所以 <code>oldThr &gt; 0</code>。</p><p>第三种情况：无参构造，这种情况下指定容量为 16，阈值为 12（16 * 0.75）。</p><p>然后补充计算一下新阈值，因为如果是第二种情况，newThr 仍然为 0。</p><p>接下来是 resize 的后半部分。</p><p>首先更新属性 threshold，创建新数组并赋值给 table，接下来迭代遍历旧 table。注意  <code>oldTab[j] = null</code>，为了方便回收器回收。</p><p>第一种情况，该桶只有一个节点，根据公式计算新索引位置，公式在 put 方法里提到过</p><p>第二种情况，该位置是红黑树节点，调用 split 方法重新分配。</p><p>第三种情况，排除前两种后，该位置只可能是链表，使用特殊处理方法。</p><p>对链表的处理比较复杂，也是 jdk8 优化的地方，jdk7 会重新计算每个元素的哈希值，而现在可以通过位运算直接判断位置。核心就是根据条件构建两条链表，根据 <code>e.hash &amp; oldCap</code> 的值，如果等于 0，将节点接入低位链（low），否则接入高位链（high）。链表遍历结束后将低位链放在原索引位置：<code>newTab[j] = loHead;</code> ，高位链移动到原索引 + oldCap 的位置上：<code>newTab[j + oldCap] = hiHead</code>。</p><p>推导一下涉及到的公式 <code>(e.hash &amp; oldCap) == 0</code>：</p><p>明确<strong>元素在表中的位置由<code>hash &amp; (n-1)</code>决定</strong>。那么 <code>e.hash &amp; oldCap</code> 实际上是在检查哈希值中对应 oldCap 那个 1 的位是否为1：如果为 1，说明扩容后位置会移动 oldCap 的长度，也就对应了该公式：<code>newTab[j + oldCap] = hiHead</code>；如果为 0，说明扩容后位置不变。</p><p>举一个具体的例子，全部用二进制表示，所描述的第几位是从低位开始数。</p><p>假设 <code>oldCap = 10000, newCap = 100000</code>。</p><p>如果元素 e 的 hash 值为 000101，第五位为 0 ，说明扩容后索引位置不变，经过验证 <code>e.hash &amp; oldCap == e.hash &amp; newCap</code>。</p><p>如果元素 e 的 hash 值为 010101，第五位为 1 ，说明扩容后索引位置增加 oldCap，经过验证 <code>(e.hash &amp; oldCap) + oldCap == e.hash &amp; newCap</code>。</p><p>妙！</p>]]></content>
      
      
      <categories>
          
          <category> Java源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁机制八股整理</title>
      <link href="/2025/12/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AB%E8%82%A1%E6%95%B4%E7%90%86/"/>
      <url>/2025/12/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%AB%E8%82%A1%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>整理一下<code>MySQL</code>锁的八股，全文整理自<a href="https://javabetter.cn/sidebar/sanfene/mysql.html#_53-%F0%9F%8C%9Fmysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81">二哥博客</a>。</p><p>在MySQL数据库中，锁是用来协调多个进程或线程并发访问同一资源的机制。锁不仅保证了数据的一致性和有效性，而且是影响数据库并发访问性能的一个重要因素。</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251206162234600.png" alt="image-20251206162234600"></p><h2 id="共享锁与排他锁">共享锁与排他锁</h2><p>共享锁也叫 S(shared) 锁，允许多个事务进行读操作，阻塞写操作。</p><p>排他锁也叫 X(exclusive) 锁，只允许一个事务进行读写操作，阻塞其他事务的读写操作。</p><p>兼容性如下：</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251206181825893.png" alt="image-20251206181825893"></p><h2 id="表锁与行锁">表锁与行锁</h2><p>表锁：锁定整个表，资源开销小，加锁快，但并发度低，不会出现死锁，适合查询为主、少量更新的场景（如 MyISAM 引擎）。可以细分为表级S锁、表级X锁。</p><p>行锁：锁定单行或多行，开销大、加锁慢，可能出现死锁，但并发度高（InnoDB 默认支持）。可以细分为记录锁、间隙锁、临键锁，也可以分为共享锁和排他锁（与表级S锁、表级X锁一个意思，前提是行锁）。</p><h3 id="表锁详细版：">表锁详细版：</h3><p>表锁常见于 MyISAM 引擎， InnoDB 也可手动加锁，适合读多写少、全表扫描或者表结构变更的场景。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES table_name READ; <span class="comment">-- 显式加读锁</span></span><br><span class="line">select...                    <span class="comment">-- 其他会话可读，不可写</span></span><br><span class="line">UNLOCK TABLES;               <span class="comment">-- 释放锁</span></span><br><span class="line"></span><br><span class="line">LOCK TABLES table_name WRITE;    <span class="comment">-- 显式加写锁 </span></span><br><span class="line"><span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span> table_name; <span class="comment">-- 其他会话读写均阻塞 </span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><p>MyISAM 在执行 <code>SELECT</code> 时会自动加读锁，执行 <code>INSERT/UPDATE/DELETE</code> 时会加写锁。</p><p>对于 InnoDB 引擎，无索引的 <code>UPDATE/DELETE</code> 可能会导致锁升级为表锁。执行 <code>ALTER TABLE</code> 时会自动加表锁，阻塞所有读写操作。</p><h3 id="行锁详细版：">行锁详细版：</h3><p>行锁是 InnoDB 存储引擎中最细粒度的锁，它锁定表中的一行记录，允许其他事务访问表中的其他行。</p><p>底层是通过给索引加锁实现的，这就意味着只有通过索引条件检索数据时，InnoDB 才能使用行级锁，否则会退化为表锁。</p><p><strong>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，默认的行锁类型为临键锁。</strong></p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251206180624673.png" alt="image-20251206180624673"></p><p>如果使用排他锁，注意两个点：第一就是必须在事务中使用，否则锁会立即释放。第二就是使用时必须注意是否命中索引，否则可能退化为表锁。</p><p>行锁又可以细分为记录锁、间隙锁和临键锁三种形式。</p><p>记录锁是行锁最基本的表现形式，当我们使用唯一索引或者主键索引进行等值查询时，MySQL 会为该记录自动添加排他锁，禁止其他事务读取或者修改锁定记录。（很奇怪）</p><p>间隙锁用于在范围查询时锁定记录之间的“间隙”，防止其他事务在该范围内插入新记录。仅在可重复读及以上的隔离级别下生效，主要用于防止幻读。</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251206200229003.png" alt="image-20251206200229003"></p><p>临键锁是记录锁和间隙锁的结合体，锁住的是索引记录和索引记录之间的间隙。临键锁的间隙是一个左开右闭区间。间隙锁为左开右开。</p><p>MySQL 默认的行锁类型就是临键锁。当使用唯一索引的等值查询匹配到一条记录时，临键锁会退化成记录锁；如果没有匹配到任何记录，会退化成间隙锁。</p><h2 id="意向锁">意向锁</h2><p>意向锁是一种表级锁，表示事务打算对表中的某些行数据加锁，但不会直接锁定数据行本身。</p><p>由 InnoDB 自动管理，当事务需要添加行锁时，会先在表上添加意向锁。这样当要添加表锁的时候，可以通过查看表上的意向锁，快速判断是否有冲突，而无需逐行检查，从而提高加锁效率。</p><p>存在的意义：在没有意向锁的情况下，当事务 A 持有某表的行锁时，如果事务 B 想添加表锁，InnoDB 必须检查表中每一行数据是否被加锁，这种全表扫描的方式效率极低。有了意向锁之后，事务在加行锁前，先在表上加对应的意向锁；其他事务加表锁时，只需检查表上的意向锁，无需逐行检查。</p><p>意向锁之间相互兼容</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251206201534917.png" alt="image-20251206201534917"></p><h2 id="乐观锁与悲观锁">乐观锁与悲观锁</h2><p>悲观锁是一种&quot;先上锁再操作&quot;的保守策略，它假设数据被外界访问时必然会产生冲突，因此在数据处理过程中全程加锁，保证同一时间只有一个线程可以访问数据。MySQL 中的行锁和表锁都是悲观锁。</p><p>乐观锁会假设并发操作不会总发生冲突，属于小概率事件，因此不会在读取数据时加锁，而是在提交更新时才检查数据是否被其他事务修改过。它并不是 MySQL 内置的锁机制，而是通过程序逻辑实现的，常见的实现方式有版本号机制和时间戳机制，对应的向表中添加 version 字段或者 timestamp 字段来实现。</p><p><a href="https://javabetter.cn/sidebar/sanfene/mysql.html#_58-%F0%9F%8C%9Fmysql%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97">如何通过悲观锁和乐观锁解决库存问题</a></p><h2 id="死锁问题">死锁问题</h2><p>MySQL 的死锁是由于多个事务持有资源并相互等待引起的。我通过 <code>SHOW ENGINE INNODB STATUS</code> 查看死锁信息，定位到是加锁顺序不一致导致的，最后通过调整加锁顺序解决了这个问题。</p><p>补充：</p><p>全局锁就是对整个数据库实例进行加锁，当执行全局锁定操作时，整个数据库将会处于只读状态，所有写操作都会被阻塞，直到全局锁被释放。</p><p>在进行全库备份，或者数据迁移时，可以使用全局锁来保证数据的一致性。</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 八股 </tag>
            
            <tag> 锁机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引八股整理</title>
      <link href="/2025/11/24/MySQL%E7%B4%A2%E5%BC%95%E5%85%AB%E8%82%A1%E6%95%B4%E7%90%86/"/>
      <url>/2025/11/24/MySQL%E7%B4%A2%E5%BC%95%E5%85%AB%E8%82%A1%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>整理一下<code>MySQL</code>索引的八股。</p><h2 id="索引介绍">索引介绍</h2><p>索引是数据库中用于加速查询的数据结构，通过对表中某列或多列的值进行排序，可以快速定位所要查找的数据。就像小时候在汉语字典里查字时，会先根据偏旁笔画数找到偏旁，然后根据剩余笔画找到目标字，这比在整个字典中一个一个查找是快很多的。</p><h2 id="索引分类">索引分类</h2><p>索引有以下分类</p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251124152320367.png" alt="image-20251124152320367" style="zoom: 25%;" /><h2 id="索引详细介绍">索引详细介绍</h2><h3 id="主键索引：">主键索引：</h3><p>主键索引用于唯一标识表中的每条记录，其值必须唯一且非空。每个表只允许有一个主键索引，一般为表中的自增id。</p><p>创建主键时，数据库会自动生成主键索引。若没有指定主键，<code>MySQL</code>的<code>InnoDB</code>存储引擎会优先选择一个非空的唯一索引作为主键，如果没有符合条件的索引，<code>MySQL</code>会自动生成一个隐藏的聚簇索引。</p><h3 id="唯一索引：">唯一索引：</h3><p>主键索引 = 唯一索引 + 非空，每个表可以有多个唯一索引，同时唯一索引允许值为NULL，这是和主键索引不同的地方。唯一索引强制字段值的唯一性，插入或更新时会触发唯一检查，适用于业务唯一性约束的字段，比如邮箱。在建表定义唯一键时，会自动生成唯一索引。</p><p>键和索引的区别在于键时逻辑概念，而索引是物理实现，在磁盘中有着实际的存储。</p><h3 id="普通索引：">普通索引：</h3><p>普通索引仅用于加速查询，不会限制字段值的唯一性。</p><h3 id="全文索引">全文索引</h3><p>全文索引是<code>MySQL</code>一种优化文本数据检索的特殊类型索引，适用于<code>CHAR, VARCHAR, TEXT</code>等字段。MySQL 5.7 及以上版本内置了 ngram 解析器，可处理中文、日文和韩文等分词。全文索引底层不再是 B+ 树索引。</p><p>建表时通过 <code>FULLTEXT (title, body)</code> 来定义。通过 <code>MATCH(col1, col2) AGAINST('keyword')</code> 进行检索，默认按照降序返回结果，支持布尔模式查询。</p><ul class="lvl-0"><li class="lvl-2"><p><code>+</code> 表示必须包含；</p></li><li class="lvl-2"><p><code>-</code> 表示排除；</p></li><li class="lvl-2"><p><code>*</code> 表示通配符；</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用布尔模式查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST(<span class="string">&#x27;+MySQL -Oracle&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure><p>这样查询性能比<code>LIKE '%keyword%'</code>高很多。对于复杂的中文场景可以用<code>Elasticsearch</code>等专业搜索引擎替代。</p><h3 id="B-树索引：">B+ 树索引：</h3><p>B+ 树是一种高度平衡的多路查找树，能有效降低磁盘的 IO 次数，并且支持有序遍历和范围查询。</p><p>相比普通二叉树，B+ 树可以将亿级数据量控制在3-4层树高，极大减少磁盘的 I/O 次数。因为树越高意味着查找数据时就需要更多的磁盘 IO，因为每一层都可能需要从磁盘加载新的节点。</p><p>相比二叉平衡树，B+ 树每个节点拥有多个子节点，可存储数据更多。</p><p>相比 B 树：B+ 树的非叶子节点只存储键值，叶子节点存储数据并通过链表连接，支持范围查询。这样的好处是非叶子节点不存储数据，就可以存储更多的键值对；叶子节点构成有序链表（双向链表），范围查询时可以直接通过叶子节点间的指针 顺序访问 整个查询范围内的记录，而无需对树进行多次遍历，查询效率高。</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20251129171723280.png" alt="image-20251129171723280"></p><p>相比哈希表：B+ 树支持范围查询和排序</p><h3 id="哈希索引：">哈希索引：</h3><p>Hash 索引基于哈希函数将键值映射到固定长度的哈希值，通过哈希值定位数据存储的位置，完全无序，只支持等值查找，速度快功能少，常见于 Memory 引擎。</p><p>InnoDB 内部使用了一种名为 “自适应哈希索引” 的技术，当某些索引值频繁访问时，InnoDB 会在 B+ 树基础上自动创建哈希索引，兼具两者的优点。</p><h3 id="聚簇索引与非聚簇索引：">聚簇索引与非聚簇索引：</h3><p>聚簇索引的叶子节点存储了完整的数据行，数据和索引是在一起的，不仅存储了主键值，还存储了其他列的值。</p><p>InnoDB 的主键索引就是聚簇索引，因此按照主键进行查询的速度会非常快。</p><p>每个表只能有一个聚簇索引，通常由主键定义。</p><p>非聚簇索引的叶子节点只包含了索引列和主键值，需要通过<strong>回表</strong>按照主键去聚簇索引查找其他列的值，唯一索引、普通索引等非主键索引都是非聚簇索引。回表通常需要访问额外的数据页，如果数据不在内存中还需要从磁盘读取，增加 I/O 开销。可通过覆盖索引或者联合索引来避免回表。</p><h2 id="补充">补充</h2><h3 id="一棵-B-树能存多少数据：">一棵 B+ 树能存多少数据：</h3><p>一棵 B+ 树能存多少数据，取决于它的分支因子和高度。在 InnoDB 中，页的默认大小为 16KB，当主键为 bigint 时，3 层 B+ 树通常可以存储约 2000 万条数据。</p><h3 id="B-树相比-B-树的三个优势">B+ 树相比 B 树的三个优势</h3><ol><li class="lvl-3"><p>B 树的每个节点既存储键值，又存储数据和指针，导致单节点存储的键值数量较少。</p></li><li class="lvl-3"><p>B 树的范围查询需要通过中序遍历逐层回溯；而 B+ 树的叶子节点通过双向链表顺序连接，范围查询只需定位起始点后顺序遍历链表即可，没有回溯开销。</p></li><li class="lvl-3"><p>B 树的数据可能存储在任意节点，假如目标数据恰好位于根节点或上层节点，查询仅需 1-2 次 I/O；但如果数据位于底层节点，则需多次 I/O，导致查询时间波动较大。</p><p>而 B+ 树的所有数据都存储在叶子节点，查询路径的长度是固定的，时间稳定为 <code>O(logN)</code>(N是数据总量)，对 MySQL 在高并发场景下的稳定性至关重要。</p></li></ol><h3 id="联合索引介绍：">联合索引介绍：</h3><p>前面提到可通过覆盖索引或者联合索引来避免回表。如果一个查询只需要访问索引中已经包含的列，那么这个查询就可以被索引“覆盖”，不需要回表，这就是覆盖索引。至于联合索引就是把多个字段放在一个索引里，必须遵循 “最左前缀” 原则。</p><p>联合索引属于非聚簇索引。与单列索引不同的是，联合索引的每个节点会存储所有索引列的值，而不仅仅是第一列的值。</p><p>关于最左前缀涉及到的一些问题：</p><ol><li class="lvl-3"><p>范围查询只能应用于最左前缀的最后一列。范围查询之后的列无法使用索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQL</span><br><span class="line">-- 索引(a,b,c)</span><br><span class="line">SELECT * FROM table <span class="type">WHERE</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> AND b &gt; <span class="number">2</span> <span class="type">AND</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>; </span><br><span class="line">-- 只能使用a和b，c无法使用索引</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>联合索引在 B+ 树中是按照最左字段优先排序构建的，如果跳过最左字段，MySQL 无法判断查找范围从哪里开始，自然也就无法使用索引。</p></li><li class="lvl-3"><p>如果查询模式是后缀通配符 <code>LIKE 'prefix%'</code>，且该字段有索引，优化器通常会使用索引。否则即便是遵循最左前缀匹配，LIKE 字段也无法命中索引。</p></li><li class="lvl-3"><p>如果排序(order by)或分组(group by)的列是最左前缀的一部分，索引还可以加速操作。</p></li></ol><h3 id="索引下推：">索引下推：</h3><p>索引下推是指：MySQL 把 WHERE 条件尽可能“下推”到索引扫描阶段，在存储引擎层提前过滤掉不符合条件的记录。</p><p>在传统的查询处理方式中，存储引擎首先根据索引读取数据并将其加载到内存中，然后在内存中应用 WHERE 子句中的过滤条件，筛选出符合条件的数据行。这种方式可能导致大量的数据传输，尤其是当数据量较大时。</p><p>而使用索引下推优化后，存储引擎在存储层就应用 WHERE 子句中的过滤条件，只有符合条件的数据才会被加载到内存中进一步处理。这可以减少数据传输量，从而提高查询效率。</p><h2 id="其他问题">其他问题</h2><h3 id="哪些情况下索引会失效：">哪些情况下索引会失效：</h3><ol><li class="lvl-3"><p>对索引列使用函数或表达式会导致索引失效。</p></li><li class="lvl-3"><p>LIKE 模糊查询以通配符开头会导致索引失效。</p></li><li class="lvl-3"><p>联合索引违反了最左前缀原则，索引会失效。</p></li><li class="lvl-3"><p>使用 OR 连接非索引列条件，会导致索引失效。</p></li><li class="lvl-3"><p>使用 <code>!=</code> 或 <code>&lt;&gt;</code> 不等值查询会导致索引失效。</p></li><li class="lvl-3"><p>（隐式类型转换也会导致索引失效）</p></li></ol><h3 id="创建索引有哪些注意点：">创建索引有哪些注意点：</h3><ol><li class="lvl-3"><p>选择合适的字段。比如说频繁出现在 WHERE、JOIN、ORDER BY、GROUP BY 中的字段。优先选择区分度高的字段，比如用户 ID、手机号等唯一值多的，而不是性别、状态等区分度极低的字段，如果真的需要，可以考虑联合索引。</p></li><li class="lvl-3"><p>要控制索引的数量，避免过度索引，每个索引都要占用存储空间，单表的索引数量不建议超过 5 个。</p></li><li class="lvl-3"><p>联合索引的时候要遵循最左前缀原则。区分度高的字段放在左侧，等值查询的字段优先于范围查询的字段。例如 <code>WHERE A=1 AND B&gt;10 AND C=2</code>，优先 <code>(A, C, B)</code>。</p></li></ol><p>全篇整理自<a href="https://javabetter.cn/sidebar/sanfene/mysql.html#%E7%B4%A2%E5%BC%95">二哥博客</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 八股 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2025/10/14/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/10/14/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型定义">泛型定义</h2><p>先看这样一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">System.out.println((String)list.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code>集合中可以加入任何类型的对象，我本意是用这个集合来存储字符串（因为<code>ArrayList</code>默认存储的是<code>Object</code>类型的对象，所以输出时需要强转 ），但我粗心的写错了<code>list.add(123)</code>，在我运行后发现报错<code>java.lang.ClassCastException</code>，显然报错原因就是输出时<code>Integer</code>类型并不能强转为<code>String</code>类型。那么如何避免这种情况呢，答案就是<strong>泛型</strong>。</p><p>借用一下维基百科的定义：</p><blockquote><p>泛型程序设计是程序设计语言的一种风格或范型，泛型允许程序员在强类型程序设计语言中 编写代码时 使用一些 以后才指定的类型，在实例化时作为参数指明这些类型。</p></blockquote><p>说一下我的理解，泛字让我联想到了一个词语：泛泛而谈，指那些浮浅平淡，不深入的谈话。这里也可以这样理解，定义时我模糊的说明一下参数，不指明参数具体是哪种类型，等我使用时再说明。</p><p>有这样一种说法：泛型的本质就是“参数化类型”。想象一下，定义一个方法需要形参，待你调用时，又需要传递实参。泛型亦是如此，定义时形式上意思意思，真正使用时再说明。其实都一个意思。</p><p>下面我将从<strong>泛型类</strong>、<strong>泛型方法</strong>、<strong>泛型接口</strong>、<strong>通配符</strong>、<strong>类型擦除</strong>五个方面来对Java泛型进行详细说明。</p><h2 id="泛型类">泛型类</h2><p>来看一下<code>ArrayList</code>这个类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>相比其他普通类，这个类的类名称后面多了个<code>&lt;E&gt;</code>，这就是泛型类的核心标识，其中 E 为类型参数，理论上可以为任何字母，但有一些约定俗成的习惯</p><ul class="lvl-0"><li class="lvl-2"><p>T：代表一般的任何类</p></li><li class="lvl-2"><p>E：element 元素的意思</p></li><li class="lvl-2"><p>K：代表 key 的意思</p></li><li class="lvl-2"><p>V：代表 value 的意思，经常和 K 搭配作为键值对</p></li></ul><p>关于类型参数怎么用，来看个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T brand;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getBrand</span><span class="params">()</span> &#123;<span class="comment">//方法返回值</span></span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(T newBrand)</span> &#123;<span class="comment">//方法形参</span></span><br><span class="line">        <span class="built_in">this</span>.brand = newBrand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有三种使用方法，代码中已做标注。注意：<strong>静态属性和静态方法中不能使用泛型类声明的类型参数</strong>。否则编译报错：<code>'org.example.myblog.generics.Vehicle.this' cannot be referenced from a static context</code></p><p>原因如下：静态成员是属于类本身的，不属于任何实例。当类加载时，泛型参数 <code>T</code> 还没有被具体类型替换（因为此时还没有任何实例被创建），编译器无法确定 <code>T</code> 的具体类型，自然也就无法为静态成员使用 <code>T</code> 分配内存或验证类型。有一个小例外，静态方法自身可以是泛型方法，详情见下文（坑1挖）。</p><p>如果把 T 视为一个真实存在的类型，其实它的使用方法与其他类型并无区别。类型参数也可以是多个，用<code>,</code>分隔。</p><h2 id="泛型接口">泛型接口</h2><p>泛型接口和泛型类差不多，下面是<code>List</code>接口的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SequencedCollection</span>&lt;E&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>说几点与泛型类不同的地方</p><ol><li class="lvl-3"><p>因为接口中的属性的修饰符默认是<code>public static final</code>，所以属性不能使用类型参数声明。除静态方法外其他方法可以使用类型参数。</p></li><li class="lvl-3"><p>在接口A继承接口B时，如果接口B是泛型接口，那么接口A可以选择确定父接口的类型参数（成为非泛型接口），也可以选择保留泛型参数并传递给父接口（自身仍是泛型接口，如<code>List</code>接口），示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父接口：泛型接口，T 是它的类型参数</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(T device)</span>; <span class="comment">// 连接设备（设备类型为 T）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子接口：保留泛型参数 E，并传递给父接口 IUsb 的 T</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;E&gt; &#123; </span><br><span class="line">    <span class="comment">// 此时父接口 IUsb 的 T 被“替换”为子接口的 E</span></span><br><span class="line">    <span class="comment">// 所以 IA 继承的方法实际是：void connect(E device)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>当一个类实现接口时，可以选择将自身泛型参数传递给接口，成为泛型实现类，也可以指定接口的泛型参数，成为一个普通的实现类。当接口有多个泛型参数时，实现类不允许部分指定（接口继承接口也不允许部分指定）。</p></li></ol><p><strong>泛型类与泛型接口的类型推断</strong>：</p><ol><li class="lvl-3"><p>类型参数的确定时机：类型参数在创建实例（泛型类）或声明子类型（泛型接口）时确定。</p></li><li class="lvl-3"><p>不指定类型参数时的类型推断：会退化为“原始类型”，将所有泛型参数视为<code>Object</code>（坑2挖），不会进行类型检查，不推荐这样使用。</p></li><li class="lvl-3"><p>指定类型参数时的类型匹配：所有使用该类型参数的成员需遵循“参数化类型”的约束：</p><ul class="lvl-2"><li class="lvl-5"><p>传入的实参必须是 “指定类型” 或其子类型。</p></li><li class="lvl-5"><p>返回值会被自动视为 “指定类型”（无需强制转换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">//Integer类型</span></span><br><span class="line">list.add(<span class="number">1.2</span>);<span class="comment">//Double类型</span></span><br></pre></td></tr></table></figure></li></ul></li><li class="lvl-3"><p>如果有多个类型参数，不允许部分指定（上文提到过）。</p></li></ol><h2 id="泛型方法">泛型方法</h2><p>在方法的返回值前加个类型参数就是泛型方法。</p><p>下面这个方法是泛型方法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> brand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然不是，它仅使用了泛型类定义的类型参数，并没有在方法签名中声明<code>&lt;T&gt;</code>，不能简单的认为泛型类里的方法就是泛型方法。下面的代码则是泛型方法，泛型方法里也可以同时声明多个类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; T <span class="title function_">genericsMethod</span><span class="params">(T t, E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的例子，<code>Test</code>是一个泛型类，泛型参数是 T ；<code>method</code>是泛型类里的一个方法，用到了泛型类的泛型参数 T ；<code>genericsMethod</code>是泛型方法，泛型参数是 E，该方法同时用到了两个泛型参数。需要注意的是，这两个泛型参数相互独立，作用域不同，泛型类的泛型参数 T 的作用域是整个类，而泛型方法的泛型参数 E 仅限于这个方法。如果泛型方法里需要同时用到该方法的泛型参数和泛型类的泛型参数，推荐分开命名，提高可读性。（这个例子不太好，方法体里并未使用到泛型参数 E）</p><p>前面提到过，在泛型类里，不允许静态方法使用泛型类声明的类型参数。但可以将静态方法声明为泛型方法。代码如下：（坑1填）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;   </span><br><span class="line"><span class="comment">// 泛型类定义的类型参数 T 不能在静态方法中使用</span></span><br><span class="line"><span class="comment">// 但可以将静态方法声明为泛型方法，方法中便可以使用其声明的类型参数了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; E <span class="title function_">show</span><span class="params">(E one)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>泛型方法的类型推断</strong>：</p><ol><li class="lvl-3"><p>确定时机：调用该方法时确定类型参数。</p></li><li class="lvl-3"><p>不指定类型参数时的类型推断：优先通过实参推断；结合返回值类型调整；多类型实参时取共同父类（最小上界）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型方法：返回两个参数中较大的一个（假设T是可比较的）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt;= <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法：创建包含一个元素的列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createList</span><span class="params">(T element)</span> &#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(element);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法：打印两个参数的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printTypes</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a.getClass().getSimpleName());</span><br><span class="line">    System.out.println(b.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************************************</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result1</span> <span class="operator">=</span> max(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">//根据实参推断 T = Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> max(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>); <span class="comment">//根据实参推断 T = String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收变量是 List&lt;Number&gt;，实参是 Integer（Number 的子类）</span></span><br><span class="line"><span class="comment">// 推断 T = Number（而非 Integer），因为返回值需要匹配 List&lt;Number&gt;</span></span><br><span class="line"><span class="comment">//如果只有createList(123); 那么编译器仅根据实参推断 T = Integer</span></span><br><span class="line">List&lt;Number&gt; numList = createList(<span class="number">123</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//实参为Integer和String,最小上界为Object，推断 T = Object</span></span><br><span class="line">printTypes(<span class="number">123</span>, <span class="string">&quot;123&quot;</span>); </span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>指定类型参数时的类型推断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1：推断可能歧义时显式指定</span></span><br><span class="line">List&lt;Number&gt; list = createList&lt;&gt;(<span class="number">123</span>); <span class="comment">// 等价于 createList&lt;Number&gt;(123)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2：实参类型与预期不符时强制指定</span></span><br><span class="line">List&lt;Object&gt; objList = createList&lt;Object&gt;(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"><span class="comment">// 显式指定 T = Object，即使实参是 String（String 是 Object 的子类，合法）</span></span><br></pre></td></tr></table></figure><p>如果泛型方法没有参数或参数不涉及泛型参数，编译器无法通过实参推断，此时需要显式指定类型参数，或通过返回值接收类型推断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型方法：创建一个空列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createEmptyList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式1：通过接收变量类型推断 T = String</span></span><br><span class="line">List&lt;String&gt; strList = createEmptyList(); </span><br><span class="line"><span class="comment">// 方式2：显式指定 T = Integer</span></span><br><span class="line">List&lt;Integer&gt; intList = createEmptyList&lt;Integer&gt;(); </span><br></pre></td></tr></table></figure></li></ol><h2 id="类型擦除">类型擦除</h2><p>在编译期，编译器会将泛型代码中的泛型参数<code>&lt;T&gt;,&lt;E&gt;</code>等等替换为边界类型（涉及到通配符的使用，下文有），如果没有边界统一替换为<code>Object</code>类型（坑2填）。在运行期，JVM眼中不存在泛型类或泛型方法。</p><p><strong>泛型类/接口的擦除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无边界泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123; <span class="keyword">private</span> T value; &#125;</span><br><span class="line"><span class="comment">// 擦除后 → class Box &#123; private Object value; &#125;</span></span><br><span class="line"><span class="comment">//有边界泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberBox</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123; <span class="keyword">private</span> T value; &#125;</span><br><span class="line"><span class="comment">// 擦除后 → class NumberBox &#123; private Number value; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>泛型方法的擦除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有边界和无边界的擦除规则同上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getFirst</span><span class="params">(List&lt;T&gt; list)</span> &#123; <span class="keyword">return</span> list.get(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="comment">// 擦除后 → public static Object getFirst(List list) &#123; return list.get(0); &#125;</span></span><br><span class="line"><span class="comment">// 调用时编译器自动补全转换：</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) getFirst(list); <span class="comment">// 手动写代码时无需加，编译器隐式添加</span></span><br></pre></td></tr></table></figure><p>泛型类被继承时，类型擦除可能导致子类方法与父类方法签名不匹配，编译器会自动生成 “桥接方法” 保证多态性，看下面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&lt;T&gt; &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt; &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String s)</span> &#123;&#125; <span class="comment">// 子类方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类擦除后方法为：public void set(Object t) &#123;&#125;,此时父类和子类的该方法形参不一致，不构成重写，但实际上有一个桥接方法</span></span><br><span class="line"><span class="comment">// 编译器为 Child 生成桥接方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object t)</span> &#123; </span><br><span class="line">    set((String) t); </span><br><span class="line">&#125; <span class="comment">// 调用子类的 set(String)</span></span><br></pre></td></tr></table></figure><p>泛型是 JDK5 引入的特性。类型擦除的设计是为了兼容 JDK5 之前的非泛型代码。但是类型擦除也带来了一定的影响，比如运行期无法获取泛型参数类型，泛型参数不能是基本类型等</p><h2 id="通配符使用">通配符使用</h2><p>泛型是类型严格的，虽然<code>String</code>是<code>Object</code>的子类，但<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>之间没有继承关系。通配符可以在保证类型安全的前提下，允许泛型类型之间的“有限兼容”。</p><h3 id="无界通配符-（表示任意类型）">无界通配符<code>&lt;?&gt;</code>（表示任意类型）</h3><p>特性：可读。适用于 <strong>“只需要读取泛型容器中的元素，不需要关心具体类型”</strong> 的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123; <span class="comment">// 只能以 Object 类型读取</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(&quot;abc&quot;); // 编译报错：无法确定添加的类型是否匹配未知类型</span></span><br><span class="line">    list.add(<span class="literal">null</span>); <span class="comment">// 唯一例外：null 可以添加，但无意义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：可接收任何 List 类型</span></span><br><span class="line">printList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()); </span><br><span class="line">printList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;()); </span><br></pre></td></tr></table></figure><h3 id="上界通配符-extends-T-（表示-T-及其子类）">上界通配符<code>&lt;? extends T&gt;</code>（表示 T 及其子类）</h3><p>特性：可读（读取的元素可视为 T 类型，即向上转型）。适用于 <strong>“需要读取泛型容器中的元素，且元素类型是 T 的子类型”</strong> 的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(List&lt;? extends Number&gt; numbers)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number num : numbers) &#123; <span class="comment">// 读取为 Number 类型（安全）</span></span><br><span class="line">        total += num.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// numbers.add(10); // 编译报错：无法确定添加的 Integer 是否匹配未知子类型（如 Double），即只知道是子类，不确定添加哪个子类</span></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：可接收 List&lt;Integer&gt;、List&lt;Double&gt; 等</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))); <span class="comment">// 6.0</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;(Arrays.asList(<span class="number">1.5</span>, <span class="number">2.5</span>))); <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><h3 id="下界通配符-super-T-（表示-T-及其父类）">下界通配符<code>&lt;? super T&gt;</code>（表示 T 及其父类）</h3><p>特性：可写（写入 T 及其子类的元素是安全的），但读取受限（读取的元素只能视为 <code>Object</code> 类型）。适用于 <strong>“需要向泛型容器中写入元素，且元素类型是 T 的子类型”</strong> 的场景（如添加元素到容器）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向列表中添加整数（列表类型可以是 Integer 的父类：Number、Object 等）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addIntegers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>); <span class="comment">// 写入 Integer 及其子类（安全，因为父类容器可接收子类对象）</span></span><br><span class="line">    list.add(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// Integer num = list.get(0); // 编译报错：读取的元素只能视为 Object，因为不清楚是哪个父类，而Object是顶级父类，所以可以用Object接受</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：可接收 List&lt;Integer&gt;、List&lt;Number&gt;、List&lt;Object&gt;</span></span><br><span class="line">addIntegers(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">addIntegers(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;());</span><br><span class="line">addIntegers(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;());</span><br></pre></td></tr></table></figure><h3 id="PECS原则">PECS原则</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>Producer Extends</strong>：如果泛型容器是 “生产者”（主要用于读取元素），使用 <code>&lt;? extends T&gt;</code>（如 <code>List&lt;? extends Number&gt;</code> 生产 Number 类型元素）。</p></li><li class="lvl-2"><p><strong>Consumer Super</strong>：如果泛型容器是 “消费者”（主要用于写入元素），使用 <code>&lt;? super T&gt;</code>（如 <code>List&lt;? super Integer&gt;</code> 消费 Integer 类型元素）。</p></li></ul><h2 id="总结">总结</h2><p>泛型在集合框架（List，Map，Set）和主流框架（Spring，Mybatis）中的频繁出现证明其重要性，所以学会使用泛型还是很重要的。</p><p>这篇博客先写到这里，感谢豆包。欢迎评论区指正，我也会继续更新，欢迎收藏<a href="https://withdong02.top">我的网站</a>。我的眼皮要闭上了😑</p><p>参考文章</p><p><a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客</a></p><p><a href="https://www.wikiwand.com/zh/articles/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型编程 - Wikiwand</a></p><p><a href="https://www.runoob.com/java/java-generics.html">Java 泛型 | 菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/09/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/09/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>正则表达式（regular expression），常简写为regex，用简单字符串来描述、匹配文中全部匹配指定格式的字符串。人话讲就是根据一些规则制定一个字符串，然后你可以用这个字符串来筛选满足规则的字符串。许多程序设计语言都支持用正则表达式操作字符串，这里主要介绍正则表达式在Java中的运用。</p><p>不同编程语言的正则表达式引擎有所不同，这里提供一个<a href="https://deerchao.cn/tutorials/regex/diffs.html">链接</a>，里面详细介绍了不同语言对各种特性的支持程度。</p><h2 id="快速使用">快速使用</h2><p>先说明一下<code>\</code>的使用。</p><p>在Java普通字符串中，反斜杠<code>\</code>本身就是转义字符，比如<code>\n</code>被转义为&quot;换行符&quot;，又比如<code>\\</code>被转义为<code>\</code>。而正则表达式也有自己的语法，它也使用反斜杠作为转义字符，比如<code>\d</code>表示“匹配一个数字”。</p><p>那么二者结合起来呢🧐。以<code>&quot;\\d&quot;</code>为例。编译器看到字符串<code>&quot;\\d&quot;</code>会根据字符串规则将其转换为两个字符，一个<code>\</code>，一个<code>d</code>。接下来正则表达式引擎会对其进行解析，最终生效的正则模式就是<code>\d</code>。可以这样理解：<strong>正则表达式需要 <code>\d</code> 来匹配数字。但在Java字符串里，一个 <code>\</code> 需要写成 <code>\\</code>。所以，要把正则的 <code>\d</code> 放到Java字符串里，就变成了 <code>\\d</code>。</strong></p><p>到底需不需要两个<code>\\</code>，idea会给你答案。</p><p><code>java.util.regex</code>包是Java标准库中用于支持正则表达式操作的包，主要涉及到<code>Pattern</code>和<code>Matcher</code>这两个类的操作。这里有个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;java\\d&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;java1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="string">&quot;javaBad&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(pattern);</span><br><span class="line"></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text1);</span><br><span class="line">System.out.println(m.matches());<span class="comment">//true</span></span><br><span class="line">m = p.matcher(text2);</span><br><span class="line">System.out.println(m.matches());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>先调用<code>Pattern</code>类的静态方法<code>compile</code>（参数为正则表达式）生成一个实例对象，通过调用该对象的<code>matcher</code>方法（参数为待匹配文本）生成一个<code>Matcher</code>实例。接下来就有很多方法供你选择，这里我调用的是<code>matches</code>方法来输出布尔值，在例子中体现为字符串Java后面能否匹配上数字。<code>Matcher</code>类里还有个<code>find</code>方法也很常见，下文会提到。</p><h2 id="匹配规则详解">匹配规则详解</h2><h3 id="简单匹配">简单匹配</h3><p>为方便演示，接下来的示例代码使用<code>String</code>类的<code>matches</code>方法，该方法底层原理仍然是<code>Pattern</code>和<code>Matcher</code>这两个类的使用，后面有详细说明。下面示例参考<a href="https://liaoxuefeng.com/books/java/reg-exp/match-rules/index.html">廖雪峰</a>和<a href="https://www.runoob.com/java/java-regular-expressions.html">菜鸟教程</a>。</p><p><strong>匹配任意字符：</strong><code>.</code>可以匹配除<code>\r\n</code>之外的任何单个字符。如<code>a.c</code>可以匹配<code>abc</code>但不能匹配<code>abbc</code>和<code>ac</code></p><p><strong>匹配数字：</strong><code>\d</code>匹配 0~9 的数字，同样只匹配一个字符。<strong>匹配非数字：</strong><code>\D</code>匹配非数字。</p><p><strong>匹配常用字符：</strong><code>\w</code>可以匹配一个字母、数字或下划线</p><p><strong>匹配空格字符：</strong><code>\s</code>可以匹配任何空白字符，包括空格、制表符、换页符等。与<code>[\f\n\r\t\v]</code>等效。<code>\W</code>和<code>\S</code>和<code>\D</code>同样是反着来的。</p><p><strong>重复匹配：</strong></p><p><code>*</code>可以匹配任意个字符，包括0个字符。</p><p><code>+</code>可以匹配至少一个字符。比如<code>A\d+</code>可以匹配<code>A11111</code>和<code>A0</code>。但不能匹配<code>A</code>,因为至少一个字符。</p><p><code>?</code>可以匹配0个或一个字符。</p><p>如果想精确指定n个字符，使用<code>&#123;n&#125;</code>，比如<code>A\d&#123;3&#125;</code>可以匹配到<code>A123</code>。指定匹配n~m个字符，用<code>&#123;n,m&#125;</code>， 例如<code>A\d&#123;3,5&#125;</code>可以精确匹配<code>A123</code> <code>A1234</code> <code>A12345</code>。<code>&#123;n,&#125;</code>表示可以匹配至少n个字符。m和n为非负整数，其中n &lt;= m。再举一个例子:<code>o&#123;2&#125;</code>和Bob中的一个o不匹配，而匹配food中的两个o。<strong>不同表达式可能是等效的，比如<code>o&#123;0,1&#125;</code>和<code>o?</code></strong></p><p>来个综合点的例子：假如电话号码规则如下:3<sub>4位数字表示区位，7</sub>8位数字表示电话，中间用<code>-</code>连接。答案：<code>\\d&#123;3,4&#125;-\\d&#123;7,8&#125;</code>。对于连字符<code>-</code>，一般情况下只是一个普通字符，不需要进行转义，当然写上两个反斜杠也是对的，idea会给出提示移除多余的反斜杠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;3,4&#125;-\\d&#123;7,8&#125;&quot;</span>;<span class="comment">//不知道需不需要写\？idea会给你的答案</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;0123-123456&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="string">&quot;010-1234567&quot;</span>;</span><br><span class="line">System.out.println(text1.matches(pattern));<span class="comment">//false</span></span><br><span class="line">System.out.println(text2.matches(pattern));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="复杂匹配：">复杂匹配：</h3><p><strong>匹配开头和结尾：</strong><code>^</code>匹配输入字符串开始的位置，<code>$</code>匹配输入字符串结束的位置。他们俩的作用是将匹配过程限制在整个字符串上，避免了在子串中成功匹配的情况。其实<code>matches()</code>方法的行为已经隐含了<code>^...$</code>锚点的效果，而<code>find()</code>方法则没有。matches方法尝试将整个输入序列与模式匹配，而find方法会在输入序列中查找下一个与模式匹配的子序列。仔细品味这两个方法的名字，你也许会理解。</p><p><strong>匹配指定范围：</strong><code>[xyz]</code>匹配包含的任一字符，比如<code>[abc]</code>匹配<code>plain</code>中的 a。<code>[a-z]</code></p><p>匹配 a 到 z 范围内的任何小写字母。<code>[^a-z]</code>匹配任何不在 a 到 z 范围内的字符，取补集的意思，和前面的<code>\b</code>，<code>\B</code>类似。<code>[0-9]</code>和<code>[A-Z]</code>同样理解。</p><p>如果要匹配6位十六进制数，可以这样写：<code>[0-9a-fA-F]&#123;6&#125;</code></p><p><strong>或规则匹配：</strong><code>AB|CD</code>表示可以匹配 AB 或 CD。<code>(z|f)ood</code>匹配 zood 或 food，当然这个正则表达式也可以写成<code>[zf]ood</code>。</p><p><strong>分组匹配：</strong> 字面意思，通过()将表达式分组处理，可以配合<code>Matcher</code>类的<code>group</code>方法使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">System.out.println(g1); <span class="comment">// 010</span></span><br><span class="line">System.out.println(g2); <span class="comment">// 12345678</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非贪婪匹配：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察这个例子，第二个输出空字符串，输出没问题，因为<code>\d+</code>可以匹配到后面的数字。正则表达式默认使用贪婪匹配，以<code>\d+</code>为例，后面有多少数字就匹配多少（只要连续），这样<code>0*</code>就匹配到空字符串。如果想让<code>\d+</code>少匹配，可以写成<code>(\\d+?)(0*)</code>，<code>?</code>表示非贪婪匹配，这样输出就变成了<code>&quot;123&quot; &quot;0000&quot;</code>。</p><p>不能简单的把非贪婪匹配认为最少匹配，觉得输出应该是<code>1</code>和<code>230000</code>。非贪婪匹配是在保证后面表达式都能匹配上的前提下尽量少匹配。引擎保证的是整体成功优先，我认为可以是一种平衡吧，这里不做过多解释，因为更深层的原理我也不懂。</p><p>这里的<code>?</code>和前面提到的<code>?</code>不一样。<code>(\d??)(9*)</code>，<code>\d?</code>表示匹配0个或1个数字，后面的<code>?</code>表示非贪婪匹配。如果给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别为<code>&quot;&quot;</code> <code>&quot;9999&quot;</code></p><h2 id="实战演练">实战演练</h2><p>**匹配邮箱：**这里假设字符@前可以出现数字、英文字母、下划线和中划线，字符@后是域名格式，长度不限。</p><p>先分析邮箱名称部分，只能出现数字、英文字母和下划线、中划线，那么可以这样写<code>[0-9a-zA-Z_-]</code>，也可以选择<code>\w</code>，这里我选择第二种。又因为不止一个字符，所以加个<code>+</code>。变成<code>\w+</code></p><p>然后分析域名部分，域名一般是<code>weixin.qq.com</code>这种类型，也就是<code>**.**.**</code>。可以以第一个英文句点为分界线将其拆解为两部分。一部分是<code>**</code>一部分是<code>.**</code>的复制粘贴。第一部分依然可以这样写<code>\w+</code>，一个<code>.**</code>这样写<code>\.\w+</code>，多个<code>.**</code>这样写<code>(.\w+)+</code>。</p><p>经过分析，答案就是<code>\w+@\w+(.\w+)+</code>，放到java中，需要写成<code>\\w+@\\w+(.\\w+)+</code>，还是那句话：到底需不需要写反斜杠，idea会给你答案。</p><p>如果你在浏览器搜索“正则表达式邮箱匹配”，你可能会得到很多答案，当你不确定时，多去尝试。</p><h2 id="拓展">拓展</h2><p><code>Matcher</code>类除了提到的<code>matches</code>方法和<code>find</code>方法，还有<code>start``replaceAll</code>等，可以点击<a href="https://www.runoob.com/java/java-regular-expressions.html">链接</a>了解更多。这里我想介绍一下<code>Pattern</code>和<code>Matcher</code>这两个类出现的其他地方，比如上文提到的<code>String.matches()</code>方法。</p><p>为什么说<code>String.matches()</code>方法底层原理仍然是<code>Pattern</code>和<code>Matcher</code>这两个类的使用。ctrl+鼠标左键点开方法源码即可发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Pattern.matches(regex, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用的是<code>Pattern</code>类的静态方法<code>matches</code>，同时传进去两个参数，一个正则表达式，一个待匹配字符串。接着点进去matches方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex, CharSequence input)</span> &#123;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(input);</span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会发现这跟之前的示例代码没啥两样，只是<code>compile</code>和<code>matcher</code>这两个方法的参数不再是字符串常量，而是传进来的参数<code>regex</code>和<code>input</code>。</p><p>再说一个例子，就是<code>String.split()</code>方法。简单说一下：这个方法最终调用的是<code>String</code>类的<code>private String[] split(String regex, int limit, boolean withDelimiters) &#123;...&#125;</code>这个方法，可以看到传进去一个正则表达式作为参数，这个方法的最后几行代码是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="keyword">return</span> withDelimiters</span><br><span class="line">? pattern.splitWithDelimiters(<span class="built_in">this</span>, limit)</span><br><span class="line">: pattern.split(<span class="built_in">this</span>, limit);</span><br></pre></td></tr></table></figure><p>根据参数<code>withDelimiters</code>的布尔值来确定调用对象pattern的哪个方法，其实这两个方法最终调用的还是一个方法，兜兜转转还是回到了<code>Pattern</code>类和<code>Matcher</code>类。</p><p>这篇博客就到这里，错误不可避免，欢迎指正。我会持续更新，欢迎收藏<a href="https://withdong02.top">我的网站</a>。</p><p>参考文章：</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://liaoxuefeng.com/books/java/reg-exp/complex-match/index.html">复杂匹配规则 - Java教程 - 廖雪峰的官方网站</a></p></li><li class="lvl-2"><p><a href="https://www.runoob.com/java/java-regular-expressions.html">Java 正则表达式 | 菜鸟教程</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/weixin_43860260/article/details/91417485">Java 正则表达式的用法和实例-CSDN博客</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2025/08/10/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2025/08/10/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射">什么是反射</h2><p>在<code>spring</code>项目中，只需要写个<code>@Service</code>或者<code>@Component</code>，然后在别的地方用<code>@Autowired</code>声明一个接口变量，<code>Spring</code>就能返回给我们一个实现了该接口的具体对象。这是如何实现的呢？它不可能在编译时就知道加了注解的类与类之间的关系，所以只能是在程序启动<strong>运行时</strong>，Spring动态地发现了这些类，读取了他们的结构，然后创建对象。这背后的技术支撑又是什么？答案就是反射。</p><p>反射是Java提供的一种在<strong>程序运行时</strong></p><ul class="lvl-0"><li class="lvl-2"><p>检查/获取类、接口、字段、方法、构造器等结构信息的能力。</p></li><li class="lvl-2"><p>操作/调用对象、字段、方法的能力。</p></li></ul><p>它就像一面镜子，让程序在运行时“照见”自己的结构。</p><h2 id="反射的基石：Class对象">反射的基石：<code>Class</code>对象</h2><p>编译器在编译 Java 源代码时会生成 <code>.class</code> 文件（字节码文件）。当 JVM 需要用到某个类时，它的类加载器会读取并解析对应的 <code>.class</code> 文件，在方法区（或元空间）构建该类的运行时数据结构，同时在堆内存中创建一个代表该类的 <strong><code>java.lang.Class</code> 对象</strong>。每个被加载的类在 JVM 中都有且只有一个对应的 <code>Class</code> 对象（在同一个类加载器命名空间内）。</p><p>这里的<code>Class</code>是一个类的名字，不要和<code>class</code>关键字搞混。</p><p>有三种方法获取<code>Class</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;me&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//法一：通过对象实例</span></span><br><span class="line">Class&lt; ? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; clazz1 = person.getClass();</span><br><span class="line"><span class="comment">//法二：自带属性（基本数据类型也有）</span></span><br><span class="line">Class&lt;Person&gt; clazz2 = Person.class;</span><br><span class="line"><span class="comment">//法三：Class类的静态方法 forName</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;org.myblog.reflection.Person&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下这三种方法泛型的使用：法一使用<code>Class&lt;? extends Person&gt; </code>因为<code>Class</code>对象是在运行时从<code>Person</code>实例获取的，而<code>Person</code>实例的具体类型只能在运行时创建和确定，编译阶段无法判断，所以使用通配符 ，又因为<code>person</code>可能是<code>Person</code>实例，也可能是<code>Person</code>的子类实例，所以最终写成<code>Class&lt; ? extends Person&gt;</code>；法二使用<code>Class&lt;Person&gt;</code>因为编译时已知具体类型；法三使用<code>Class&lt;?&gt;</code>因为通过字符串动态加载类，编译时无法确定具体类型，所以使用通配符。这三个 Class 对象都是同一个（上面也提到了，一个类唯一对应一个 Class 对象）。</p><p><strong>最常用、最灵活的是法三</strong></p><h2 id="反射的核心操作">反射的核心操作</h2><p><code>Person</code>类具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">species</span> <span class="operator">=</span> <span class="string">&quot;Human&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;,I&#x27;m &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">celebrateBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        age++;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is now &quot;</span> + age + <span class="string">&quot; years old!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">describeSpecies</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;We are all &quot;</span> + species);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取类的信息">获取类的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.example.myblog.reflection.Person&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;类名：&quot;</span> + clazz.getName());</span><br><span class="line">System.out.println(<span class="string">&quot;包名：&quot;</span> + clazz.getPackage().getName());</span><br><span class="line">System.out.println(<span class="string">&quot;父类：&quot;</span> + clazz.getSuperclass());</span><br><span class="line">System.out.println(<span class="string">&quot;接口：&quot;</span> + Arrays.toString(clazz.getInterfaces()));</span><br><span class="line">System.out.println(<span class="string">&quot;修饰符：&quot;</span> + Modifier.toString(clazz.getModifiers()));</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名：org.example.myblog.reflection.Person</span><br><span class="line">包名：org.example.myblog.reflection</span><br><span class="line">父类：class java.lang.Object</span><br><span class="line">接口：[]</span><br><span class="line">修饰符：public</span><br></pre></td></tr></table></figure><h3 id="操作字段">操作字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;操作字段+++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : allFields) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;- &quot;</span> + Modifier.toString(f.getModifiers()) + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    f.getType().getSimpleName() + <span class="string">&quot; &quot;</span> + f.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;me&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//访问public字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(nameField.get(me));</span><br><span class="line"><span class="comment">//访问private字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(ageField.get(me));</span><br><span class="line">ageField.set(me, <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改后年龄: &quot;</span> + ageField.get(me));</span><br><span class="line"><span class="comment">//访问static字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">speciesField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;species&quot;</span>);</span><br><span class="line">System.out.println(speciesField.get(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">public</span> String name</span><br><span class="line">- <span class="keyword">private</span> <span class="type">int</span> age</span><br><span class="line">- <span class="keyword">public</span> <span class="keyword">static</span> String species</span><br><span class="line">me</span><br><span class="line"><span class="number">20</span></span><br><span class="line">修改后年龄: <span class="number">18</span></span><br><span class="line">Human</span><br></pre></td></tr></table></figure><p>说明几点：</p><ol><li class="lvl-3"><p><code>getDeclaredFields()</code>是获取所有字段，并返回一个数组，<code>getField</code>则是根据参数返回指定字段，返回的是<code>Field</code>实例。</p></li><li class="lvl-3"><p>最后一行<code>speciesField.get(null)</code>传入参数<code>null</code>，因为静态字段是属于这个类的，当然也可以传入对象<code>me</code>。</p></li><li class="lvl-3"><p><code>ageField.setAccessible(true);</code>这个方法传入参数<code>true</code>表示<strong>屏蔽Java语言的访问检查</strong>。看下面这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : allFields) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> Modifier.isStatic(f.getModifiers()) ? <span class="literal">null</span> : me;</span><br><span class="line">    System.out.println(<span class="string">&quot;  可访问性: &quot;</span> + f.canAccess(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   public String name</span><br><span class="line">   可访问性: true</span><br><span class="line">   private int age</span><br><span class="line">   可访问性: false</span><br><span class="line">   public static String species</span><br><span class="line">   可访问性: true</span><br><span class="line"></span><br><span class="line">​输出如上，`age`是不可访问的，在`setAccessible(true)`后可以访问并修改。否则会报错。</span><br><span class="line"></span><br><span class="line">4. 如果想要访问`private`或其他非`public`字段，必须使用`getDeclaredField()`，**注意里面有`Declared`，这个规律同样适用后面的`Method`和`Constructor`。**</span><br><span class="line"></span><br><span class="line">### 操作方法</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">System.out.println(&quot;\n==== 方法操作 ====&quot;);</span><br><span class="line">Person Dong = new Person(&quot;dong&quot;, 18);</span><br><span class="line">Method[] allMethods = clazz.getDeclaredMethods();</span><br><span class="line">System.out.println(&quot;所有方法:&quot;);</span><br><span class="line">for (Method m : allMethods) &#123;</span><br><span class="line">System.out.println(&quot;- &quot; + m.getName() + &quot;()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 调用public方法</span><br><span class="line">Method greetMethod = clazz.getMethod(&quot;greet&quot;, String.class);</span><br><span class="line">greetMethod.invoke(Dong, &quot;李明&quot;);</span><br><span class="line">// 调用private方法</span><br><span class="line">Method birthdayMethod = clazz.getDeclaredMethod(&quot;celebrateBirthday&quot;);</span><br><span class="line">birthdayMethod.setAccessible(true);</span><br><span class="line">birthdayMethod.invoke(Dong);</span><br><span class="line">System.out.println(&quot;新年龄: &quot; + ageField.get(Dong)); // 验证年龄增加</span><br><span class="line">// 调用static方法</span><br><span class="line">Method speciesMethod = clazz.getMethod(&quot;describeSpecies&quot;);</span><br><span class="line">speciesMethod.invoke(null);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">所有方法:</span><br><span class="line">- celebrateBirthday()</span><br><span class="line">- describeSpecies()</span><br><span class="line">- greet()</span><br><span class="line">Hello 李明,I&#x27;m dong</span><br><span class="line">dong is now 19 years old!</span><br><span class="line">新年龄: 19</span><br><span class="line">We are all Human</span><br></pre></td></tr></table></figure><p>其实和操作字段有很多相似之处，这里说一下<code>invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">greetMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;greet&quot;</span>, String.class);</span><br><span class="line">greetMethod.invoke(Dong, <span class="string">&quot;李明&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>getMethod</code>方法有两个参数，一个是方法名称，一个是参数的<code>class</code>对象</p><p><code>greetMethod</code>方法同样有两个参数，一个是对象实例（如果是静态方法则传入<code>null</code>），一个是传递的参数。这两个方法的参数个数不是固定的(其实是个数组)，这取决于目标方法的参数个数。</p><h3 id="操作构造器">操作构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">System.out.println(<span class="string">&quot;所有构造器:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; c : constructors) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;参数数量: &quot;</span> + c.getParameterCount());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用public无参构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; emptyConstructor = clazz.getConstructor();</span><br><span class="line"><span class="type">Person</span> <span class="variable">unknown</span> <span class="operator">=</span> (Person) emptyConstructor.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;无参构造创建: &quot;</span> + unknown.name);</span><br><span class="line"><span class="comment">// 使用public带参构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; paramConstructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Person</span> <span class="variable">sarah</span> <span class="operator">=</span> (Person) paramConstructor.newInstance(<span class="string">&quot;Sarah&quot;</span>, <span class="number">28</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;带参构造创建: &quot;</span> + sarah.name + <span class="string">&quot;, &quot;</span> + ageField.get(sarah));</span><br><span class="line"><span class="comment">// 使用private构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; privateConstructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">privateConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">secret</span> <span class="operator">=</span> (Person) privateConstructor.newInstance(<span class="string">&quot;Secret&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;私有构造创建: &quot;</span> + secret.name + <span class="string">&quot;, &quot;</span> + ageField.get(secret));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所有构造器:</span><br><span class="line">参数数量: 1</span><br><span class="line">参数数量: 2</span><br><span class="line">参数数量: 0</span><br><span class="line">无参构造创建: Unknown</span><br><span class="line">带参构造创建: Sarah, 28</span><br><span class="line">私有构造创建: Secret, 18</span><br></pre></td></tr></table></figure><p>经过前面叙述，这里的相关方法也是很好理解，<code>getConstructor</code>方法的参数取决于你拿到的构造器的参数（其实也是个数组）。</p><p><code>newInstance()</code>方法可以根据你拿到的构造器来创建该构造器所在类的实例，参数同上理解。例子中是直接强转类型了，如果<code>clazz</code>是用法二得到的，也可以使用<code>cast</code>方法进行类型转换。一般来说这个方法创建的实例用<code>Object</code>来接收，因为创建的对象是在运行时动态生成的，编译阶段无法知道。<strong>建议使用反射直接调用和操作对象的方法和字段，而不是先进行类型转换，毕竟如果在编写阶段已经明确了要转换的类型，那么直接显示地调用更合适，而不必依赖于反射。反射的真正价值在于处理编译时未知的类型，从而编写更具有通用性的代码。</strong></p><p>示例里用<code>Constructor&lt;?&gt;</code>接收<code>clazz.getConstructor()</code>创建的实例是因为<code>clazz</code>的创建就使用的是通配符。如果在创建时指定类，那便可以指定泛型参数，相当于构造器就知道自己要构造的对象是什么类型了。</p><h2 id="结尾">结尾</h2><p>上述内容只是反射部分的冰山一角，我已经尽我所能把这“一角”讲述清楚。</p><p>反射很强，它能提供运行时动态操作类和对象的能力，是很多框架的基石，但同时它也带来了很多问题，性能开销大、代码可读性差等等。在日常开发中，程序员还是会优先选择直接调用、接口、设计模式等更清晰、高效的方式。</p><p>有机会我也会更新一个与反射有关的实战案例，欢迎收藏我的网站。</p><p>参考文章：</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">大白话说Java反射：入门、使用、原理 - 陈树义 - 博客园</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遇到的奇葩BUG</title>
      <link href="/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/"/>
      <url>/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/</url>
      
        <content type="html"><![CDATA[<p>此篇博客记录我学习过程中遇到的奇葩BUG</p><h2 id="SpringBoot项目启动失败"><code>SpringBoot</code>项目启动失败</h2><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250801212248493.png" alt="image-20250801212248493"></p><p>如上图，<code>SpringBoot</code>项目启动失败。</p><p>虽然说是端口占用，但我执行相关命令后没有任何输出，修改启动端口不行，尝试了很多办法都未成功，那只好使出我的终极大招：重启idea。还是不行。幸好我还有终极终极大招：重启电脑。嘿，你猜怎么着，成了！🤣</p><h2 id="接口测试报错getaddrinfo-ENOTFOUND-https">接口测试报错<code>getaddrinfo ENOTFOUND https</code></h2><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250827154544934.png" alt="image-20250827154544934"></p><p>一次简单的接口测试，出现报错<code>getaddrinfo ENOTFOUND https</code>，搜索后得到答案：这通常意味着应用程序无法解析主机名或域名。这可能是由于DNS配置问题、网络连接问题或拼写错误等原因导致的。前两个果断排除，开始以为参数错，但一想那不应该试着错误，后来想可能域名错，但也没找到错误。最后发现是<code>https:</code>后面多了个空格。😑</p><h2 id="mysql容器连接报错">mysql容器连接报错</h2><p>情况描述：本机为windows系统，装有wsl。在配置一个项目时使用<code>docker-compose</code>命令构建项目所需容器。构建好容器后，我测试mysql是否连接成功，结果出现报错<code>2013 - Lost connection to server at 'handshake: reading initial communication packet', system error: 0</code>.</p><p>于是到网上搜索解决方案，有注释掉<code>bind-address = 127.0.0.1</code>的，有添加配置<code>skip-name-resolve</code>的，还有换系统的，但都无法解决我的问题。直到看见这篇博客<a href="https://blog.csdn.net/liudongyang123/article/details/108381944">CSDN博客</a>。于是我直接修改<code>docker-compose.yaml</code>文件，添加<code>network_mode: host</code>，同时从豆包处得知：使用 <code>host</code> 网络模式后，容器会直接使用宿主机的网络栈，因此 <code>ports</code> 配置会被忽略。如果需要 MySQL 监听 3307 端口，需在 MySQL 配置文件（<code>/etc/my.cnf</code> 目录下的配置）中添加 <code>port=3307</code>，照做后问题解决。</p><p>还要记得修改<code>application.yml</code>中的端口设置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化与反序列化</title>
      <link href="/2025/07/07/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/07/07/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化和反序列化">什么是序列化和反序列化</h2><p>序列化，人话讲就是将对象转换为字节序列（也可以是JSON、XML等文本格式），反序列化就是把这个过程倒置。</p><p>下面是维基百科关于序列化的介绍</p><blockquote><p><strong>序列化</strong>（serialization）在<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">计算机科学</a>的资料处理中，是指将<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>或<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%B8)">对象</a>状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%BB%84">字节</a>的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是<strong>反序列化</strong>（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>对于Java这种面向对象的编程语言来说，是对实例化后的对象进行序列化，而对于C++这种半面向对象的编程语言来说，序列化的目标不仅有对象（class）还有数据结构（struct）</p><h2 id="序列化的使用场景">序列化的使用场景</h2><ol><li class="lvl-3"><p>数据存储：比如序列化可以将存储在 JVM 堆区中的对象转换成字节序列，从而实现持久化。</p></li><li class="lvl-3"><p>网络通信：将对象转换为字节序列方便其在网络中进行传递和接收。</p></li></ol><h2 id="使用Java实现序列化">使用Java实现序列化</h2><p>以 JDK 自带序列化方法为例，实现<code>java.io.Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        cat.setAge(<span class="number">2</span>);</span><br><span class="line">        cat.setBirth(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//使用ObjectOutputStream将cat对象序列化并存入test1.txt文件中</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream)) &#123;</span><br><span class="line">            objectOutputStream.writeObject(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">deserializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用ObjectInputStream对test.txt文件读取并反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream)) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) objectInputStream.readObject();</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=2, name=tom, birth=Fri Jul 04 21:37:13 CST 2035)</span><br></pre></td></tr></table></figure><p>接下来让我们走进<code>Serializable</code>的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错，<code>Serializable</code>接口中没有任何方法和字段，它的作用仅仅是告诉JVM：实现该接口的类可以被序列化，</p><p>其实除了实现<code>Serializable</code>接口外，还有一个选择就是实现<code>Externalizable</code>接口（该接口是<code>Serializable</code>的子接口），不过需要重写两个方法，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(birth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        birth = (Date) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化代码一样，最终结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=0, name=tom, birth=Fri Jul 04 21:43:23 CST 2025)</span><br></pre></td></tr></table></figure><p><code>writeExternal</code>和<code>readExternal</code>可以自定义哪些字段需要序列化，我这个例子中就没有对<code>age</code>进行操作，在反序列化后它被赋初值0。需要注意的是</p><blockquote><p>The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</p></blockquote><p>翻译过来意思就是这两个方法应该用相同的顺序和相同的类型对字段进行读写，相同的顺序容易理解，相同的类型意思就是在<code>readExternal</code>中强转的目标类型必须和<code>writeExternal</code>原类型保持一致。在实现<code>Externalizable</code>接口时，还有一点需要注意的是序列化对象中必须提供无参构造，以Cat类为例,当我加入一个有参构造覆盖默认无参构造后，序列化正常运行，反序列化出现报错</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250705112136780.png" alt="image-20250705112136780"></p><p><strong>关于序列化有几点需要注意：</strong></p><ol><li class="lvl-3"><p>只有实现该接口的类才可以被序列化。</p></li><li class="lvl-3"><p>可序列化类的所有子类是可以被序列化的。不可序列化类的子类型可以被序列化。</p></li><li class="lvl-3"><p>如果不想对某个变量序列化，可以用<code>transient</code>关键字修饰，它只能修饰变量，不能修饰类和方法。<code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</p></li><li class="lvl-3"><p>序列化运行时会为每个可序列化类分配一个版本号<code>serialVersionUID</code>该版本号在序列化机制中用于验证类的版本是否一致，如果反序列化时的UID和原来序列化的UID不同，则会抛出<code>InvalidClassException</code>。</p><p>这个字段可以手动显示声明，也可以自动生成。如果显示声明，这个字段必须是<code>static</code> <code>final</code>且类型为<code>long</code>的。如果该字段未被显示声明，JVM会根据该类的结构自动生成一个<code>serialVersionUID</code>，枚举类的<code>serialVersionUID</code>会被定义为0L。</p><p>官方强烈建议除了枚举类型以外的所有可序列化类显示声明<code>serialVersionUID</code>值，因为生成算法对类的细节非常敏感（如方法、字段等的变化都会导致<code>serialVersionUID</code>改变），从而导致兼容性问题。显式设置 <code>serialVersionUID </code>可以确保在类发生非兼容更改时由开发者主动决定是否更新 UID，而不是因为类结构微小变化而导致反序列化失败。同时官方建议使用private来声明<code>serialVersionUID</code>，因为该字段不会被子类继承使用，因此没必要设置为<code>public</code>或<code>protected</code>。下面是一个完整的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serial</span><span class="comment">//Java14后建议添加</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>这时小明举手说：老师老师，如果<code>serialVersionUID</code>被<code>static</code>修饰，那他就属于这个类，而不属于实例化后的对象了，那怎么将这个字段序列化呢？老师说：好问题，<s>我也不知道。</s> 序列化保存的是对象的状态，也就是实例变量的值，然而<code>serialVersionUID</code>是一个特例，它本身确实不作为对象状态被序列化，但它的值被序列化机制特殊处理了。屏幕前的你明白了吗，反正我还是有点糊涂，我觉得把它视为一个特例就好了，要真正弄懂怕是要搞明白JVM，那要很久以后了。</p></li></ol><h2 id="Java反序列化漏洞">Java反序列化漏洞</h2><p>这里我推荐观看<a href="https://5i1encee.top/">5i1encee</a>的相关博客，关于反序列化漏洞我简要介绍一下。</p><p>当攻击者通过构造恶意输入，让反序列化产生非预期的的对象，那么在反序列化这个过程中就可能执行恶意代码。已经有多个版本的库或框架被发现存在反序列化漏洞，如<code>Apache Commons Collections</code> 。借用<a href="https://www.zhihu.com/question/37562657/answer/1916596031">一位大哥</a>的例子来简单说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerabilityTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>MyObject</code>这个类中，自定义了<code>readObject</code>这个方法，相当于可以自己决定对哪些字段反序列化。在<code>readObject</code>这个方法里通过调用<code>defaultReadObject</code>来实现默认的反序列化机制。之后执行了名为<code>calc</code>的系统命令，这是<code>Windows</code>下启动计算器的命令。当我进行反序列化操作时，电脑上的计算器也随之启动。实际上，Java 反序列化漏洞产生的原因大多数是因为反序列化时没有进行校验，或者有些校验使用黑名单方式又被绕过，最终使得包含恶意代码的序列化对象在服务器端被反序列化执行。</p><h2 id="其他序列化协议">其他序列化协议</h2><p>上述有关代码的举例均是 JDK 自带的序列化协议，但它在开发中很少被使用，主要原因如下：</p><ol><li class="lvl-3"><p>严重的安全风险：正如例子中提到的<code>readObject</code>方法，攻击者可构造恶意序列化数据触发任意代码执行</p></li><li class="lvl-3"><p>跨语言兼容性差：该协议序列化后的二进制数据只能被 Java 程序识别，无法与其他语言交互，多语言协作困难。</p></li><li class="lvl-3"><p>性能低下：序列化后的二进制数据体积远大于 JSON 或其他二进制协议。同时因为需要反射和递归处理对象图，导致速度较慢。</p></li></ol><p>常用的序列化协议有Hessian、Kryo、 Protobuf、 ProtoStuff 等，这些都是基于二进制的序列化协议。SpringBoot 项目中也可以集成 Jackson、Fastjson 等将对象序列化为JSON格式的库。</p><p>第一篇博客先写到这里，个人理解难免有偏差，欢迎评论区指正。我以后也会继续更新，欢迎收藏<a href="https://withdong02.top">我的网站</a>。</p><p>参考文章：</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解 | JavaGuide</a></p></li><li class="lvl-2"><p><a href="https://www.zhihu.com/question/37562657/answer/1916596031">(6 封私信 / 70 条消息) Java反序列化安全漏洞怎么回事? - 知乎</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
