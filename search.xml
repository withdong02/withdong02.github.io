<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java泛型</title>
      <link href="/2025/10/14/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2025/10/14/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h2><p>先看这样一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">System.out.println((String)list.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code>集合中可以加入任何类型的对象，我本意是用这个集合来存储字符串（因为**<code>ArrayList</code>默认存储的是<code>Object</code>类型的对象，所以输出时需要强转**），但我粗心的写错了<code>list.add(123)</code>，在我运行后发现报错<code>java.lang.ClassCastException</code>，显然报错原因就是输出时<code>Integer</code>类型并不能强转为<code>String</code>类型。那么如何避免这种情况呢，答案就是<strong>泛型</strong>。</p><p>借用一下维基百科的定义：</p><blockquote><p>泛型程序设计是程序设计语言的一种风格或范型，泛型允许程序员在强类型程序设计语言中 编写代码时 使用一些 以后才指定的类型，在实例化时作为参数指明这些类型。</p></blockquote><p>说一下我的理解，泛字让我联想到了一个词语：泛泛而谈，指那些浮浅平淡，不深入的谈话。这里也可以这样理解，定义时我模糊的说明一下参数，不指明参数具体是哪种类型，等我使用时再说明。</p><p>有这样一种说法：泛型的本质就是“参数化类型”。想象一下，定义一个方法需要形参，待你调用时，又需要传递实参。泛型亦是如此，定义时形式上意思意思，真正使用时再说明。其实都一个意思。</p><p>下面我将从<strong>泛型类</strong>、<strong>泛型方法</strong>、<strong>泛型接口</strong>、<strong>通配符</strong>、<strong>类型擦除</strong>五个方面来对Java泛型进行详细说明。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>来看一下<code>ArrayList</code>这个类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>相比其他普通类，这个类的类名称后面多了个<code>&lt;E&gt;</code>，这就是泛型类的核心标识，其中 E 为类型参数，理论上可以为任何字母，但有一些约定俗成的习惯</p><ul><li>T：代表一般的任何类</li><li>E：element 元素的意思</li><li>K：代表 key 的意思</li><li>V：代表 value 的意思，经常和 K 搭配作为键值对</li></ul><p>关于类型参数怎么用，来看个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T brand;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getBrand</span><span class="params">()</span> &#123;<span class="comment">//方法返回值</span></span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(T newBrand)</span> &#123;<span class="comment">//方法形参</span></span><br><span class="line">        <span class="built_in">this</span>.brand = newBrand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有三种使用方法，代码中已做标注。注意：<strong>静态属性和静态方法中不能使用泛型类声明的类型参数</strong>。否则编译报错：<code>&#39;org.example.myblog.generics.Vehicle.this&#39; cannot be referenced from a static context</code></p><p>原因如下：静态成员是属于类本身的，不属于任何实例。当类加载时，泛型参数 <code>T</code> 还没有被具体类型替换（因为此时还没有任何实例被创建），编译器无法确定 <code>T</code> 的具体类型，自然也就无法为静态成员使用 <code>T</code> 分配内存或验证类型。有一个小例外，静态方法自身可以是泛型方法，详情见下文（坑1挖）。</p><p>如果把 T 视为一个真实存在的类型，其实它的使用方法与其他类型并无区别。类型参数也可以是多个，用<code>,</code>分隔。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口和泛型类差不多，下面是<code>List</code>接口的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SequencedCollection</span>&lt;E&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>说几点与泛型类不同的地方</p><ol><li><p>因为接口中的属性的修饰符默认是<code>public static final</code>，所以属性不能使用类型参数声明。除静态方法外其他方法可以使用类型参数。</p></li><li><p>在接口A继承接口B时，如果接口B是泛型接口，那么接口A可以选择确定父接口的类型参数（成为非泛型接口），也可以选择保留泛型参数并传递给父接口（自身仍是泛型接口，如<code>List</code>接口），示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父接口：泛型接口，T 是它的类型参数</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(T device)</span>; <span class="comment">// 连接设备（设备类型为 T）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子接口：保留泛型参数 E，并传递给父接口 IUsb 的 T</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;E&gt; &#123; </span><br><span class="line">    <span class="comment">// 此时父接口 IUsb 的 T 被“替换”为子接口的 E</span></span><br><span class="line">    <span class="comment">// 所以 IA 继承的方法实际是：void connect(E device)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类实现接口时，可以选择将自身泛型参数传递给接口，成为泛型实现类，也可以指定接口的泛型参数，成为一个普通的实现类。当接口有多个泛型参数时，实现类不允许部分指定（接口继承接口也不允许部分指定）。</p></li></ol><p><strong>泛型类与泛型接口的类型推断</strong>：</p><ol><li><p>类型参数的确定时机：类型参数在创建实例（泛型类）或声明子类型（泛型接口）时确定。</p></li><li><p>不指定类型参数时的类型推断：会退化为“原始类型”，将所有泛型参数视为<code>Object</code>（坑2挖），不会进行类型检查，不推荐这样使用。</p></li><li><p>指定类型参数时的类型匹配：所有使用该类型参数的成员需遵循“参数化类型”的约束：</p><ul><li><p>传入的实参必须是 “指定类型” 或其子类型。</p></li><li><p>返回值会被自动视为 “指定类型”（无需强制转换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">//Integer类型</span></span><br><span class="line">list.add(<span class="number">1.2</span>);<span class="comment">//Double类型</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果有多个类型参数，不允许部分指定（上文提到过）。</p></li></ol><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在方法的返回值前加个类型参数就是泛型方法。</p><p>下面这个方法是泛型方法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> brand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然不是，它仅使用了泛型类定义的类型参数，并没有在方法签名中声明<code>&lt;T&gt;</code>，不能简单的认为泛型类里的方法就是泛型方法。下面的代码则是泛型方法，泛型方法里也可以同时声明多个类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; T <span class="title function_">genericsMethod</span><span class="params">(T t, E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的例子，<code>Test</code>是一个泛型类，泛型参数是 T ；<code>method</code>是泛型类里的一个方法，用到了泛型类的泛型参数 T ；<code>genericsMethod</code>是泛型方法，泛型参数是 E，该方法同时用到了两个泛型参数。需要注意的是，这两个泛型参数相互独立，作用域不同，泛型类的泛型参数 T 的作用域是整个类，而泛型方法的泛型参数 E 仅限于这个方法。如果泛型方法里需要同时用到该方法的泛型参数和泛型类的泛型参数，推荐分开命名，提高可读性。（这个例子不太好，方法体里并未使用到泛型参数 E）</p><p>前面提到过，在泛型类里，不允许静态方法使用泛型类声明的类型参数。但可以将静态方法声明为泛型方法。代码如下：（坑1填）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;   </span><br><span class="line"><span class="comment">// 泛型类定义的类型参数 T 不能在静态方法中使用</span></span><br><span class="line"><span class="comment">// 但可以将静态方法声明为泛型方法，方法中便可以使用其声明的类型参数了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; E <span class="title function_">show</span><span class="params">(E one)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>泛型方法的类型推断</strong>：</p><ol><li><p>确定时机：调用该方法时确定类型参数。</p></li><li><p>不指定类型参数时的类型推断：优先通过实参推断；结合返回值类型调整；多类型实参时取共同父类（最小上界）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型方法：返回两个参数中较大的一个（假设T是可比较的）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt;= <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法：创建包含一个元素的列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createList</span><span class="params">(T element)</span> &#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(element);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法：打印两个参数的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printTypes</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a.getClass().getSimpleName());</span><br><span class="line">    System.out.println(b.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************************************</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result1</span> <span class="operator">=</span> max(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">//根据实参推断 T = Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> max(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>); <span class="comment">//根据实参推断 T = String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收变量是 List&lt;Number&gt;，实参是 Integer（Number 的子类）</span></span><br><span class="line"><span class="comment">// 推断 T = Number（而非 Integer），因为返回值需要匹配 List&lt;Number&gt;</span></span><br><span class="line"><span class="comment">//如果只有createList(123); 那么编译器仅根据实参推断 T = Integer</span></span><br><span class="line">List&lt;Number&gt; numList = createList(<span class="number">123</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//实参为Integer和String,最小上界为Object，推断 T = Object</span></span><br><span class="line">printTypes(<span class="number">123</span>, <span class="string">&quot;123&quot;</span>); </span><br></pre></td></tr></table></figure></li><li><p>指定类型参数时的类型推断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1：推断可能歧义时显式指定</span></span><br><span class="line">List&lt;Number&gt; list = createList&lt;&gt;(<span class="number">123</span>); <span class="comment">// 等价于 createList&lt;Number&gt;(123)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2：实参类型与预期不符时强制指定</span></span><br><span class="line">List&lt;Object&gt; objList = createList&lt;Object&gt;(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"><span class="comment">// 显式指定 T = Object，即使实参是 String（String 是 Object 的子类，合法）</span></span><br></pre></td></tr></table></figure><p>如果泛型方法没有参数或参数不涉及泛型参数，编译器无法通过实参推断，此时需要显式指定类型参数，或通过返回值接收类型推断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型方法：创建一个空列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createEmptyList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式1：通过接收变量类型推断 T = String</span></span><br><span class="line">List&lt;String&gt; strList = createEmptyList(); </span><br><span class="line"><span class="comment">// 方式2：显式指定 T = Integer</span></span><br><span class="line">List&lt;Integer&gt; intList = createEmptyList&lt;Integer&gt;(); </span><br></pre></td></tr></table></figure></li></ol><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>在编译期，编译器会将泛型代码中的泛型参数<code>&lt;T&gt;,&lt;E&gt;</code>等等替换为边界类型（涉及到通配符的使用，下文有），如果没有边界统一替换为<code>Object</code>类型（坑2填）。在运行期，JVM眼中不存在泛型类或泛型方法。</p><p><strong>泛型类&#x2F;接口的擦除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无边界泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123; <span class="keyword">private</span> T value; &#125;</span><br><span class="line"><span class="comment">// 擦除后 → class Box &#123; private Object value; &#125;</span></span><br><span class="line"><span class="comment">//有边界泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberBox</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123; <span class="keyword">private</span> T value; &#125;</span><br><span class="line"><span class="comment">// 擦除后 → class NumberBox &#123; private Number value; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>泛型方法的擦除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有边界和无边界的擦除规则同上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getFirst</span><span class="params">(List&lt;T&gt; list)</span> &#123; <span class="keyword">return</span> list.get(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="comment">// 擦除后 → public static Object getFirst(List list) &#123; return list.get(0); &#125;</span></span><br><span class="line"><span class="comment">// 调用时编译器自动补全转换：</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) getFirst(list); <span class="comment">// 手动写代码时无需加，编译器隐式添加</span></span><br></pre></td></tr></table></figure><p>泛型类被继承时，类型擦除可能导致子类方法与父类方法签名不匹配，编译器会自动生成 “桥接方法” 保证多态性，看下面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&lt;T&gt; &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt; &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String s)</span> &#123;&#125; <span class="comment">// 子类方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类擦除后方法为：public void set(Object t) &#123;&#125;,此时父类和子类的该方法形参不一致，不构成重写，但实际上有一个桥接方法</span></span><br><span class="line"><span class="comment">// 编译器为 Child 生成桥接方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object t)</span> &#123; </span><br><span class="line">    set((String) t); </span><br><span class="line">&#125; <span class="comment">// 调用子类的 set(String)</span></span><br></pre></td></tr></table></figure><p>泛型是 JDK5 引入的特性。类型擦除的设计是为了兼容 JDK5 之前的非泛型代码。但是类型擦除也带来了一定的影响，比如运行期无法获取泛型参数类型，泛型参数不能是基本类型等</p><h2 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h2><p>泛型是类型严格的，虽然<code>String</code>是<code>Object</code>的子类，但<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>之间没有继承关系。通配符可以在保证类型安全的前提下，允许泛型类型之间的“有限兼容”。</p><h3 id="无界通配符（表示任意类型）"><a href="#无界通配符（表示任意类型）" class="headerlink" title="无界通配符&lt;?&gt;（表示任意类型）"></a>无界通配符<code>&lt;?&gt;</code>（表示任意类型）</h3><p>特性：可读。适用于 <strong>“只需要读取泛型容器中的元素，不需要关心具体类型”</strong> 的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123; <span class="comment">// 只能以 Object 类型读取</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(&quot;abc&quot;); // 编译报错：无法确定添加的类型是否匹配未知类型</span></span><br><span class="line">    list.add(<span class="literal">null</span>); <span class="comment">// 唯一例外：null 可以添加，但无意义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：可接收任何 List 类型</span></span><br><span class="line">printList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()); </span><br><span class="line">printList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;()); </span><br></pre></td></tr></table></figure><h3 id="上界通配符（表示-T-及其子类）"><a href="#上界通配符（表示-T-及其子类）" class="headerlink" title="上界通配符&lt;? extends T&gt;（表示 T 及其子类）"></a>上界通配符<code>&lt;? extends T&gt;</code>（表示 T 及其子类）</h3><p>特性：可读（读取的元素可视为 T 类型，即向上转型）。适用于 **“需要读取泛型容器中的元素，且元素类型是 T 的子类型” **的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(List&lt;? extends Number&gt; numbers)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number num : numbers) &#123; <span class="comment">// 读取为 Number 类型（安全）</span></span><br><span class="line">        total += num.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// numbers.add(10); // 编译报错：无法确定添加的 Integer 是否匹配未知子类型（如 Double），即只知道是子类，不确定添加哪个子类</span></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：可接收 List&lt;Integer&gt;、List&lt;Double&gt; 等</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))); <span class="comment">// 6.0</span></span><br><span class="line">sum(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;(Arrays.asList(<span class="number">1.5</span>, <span class="number">2.5</span>))); <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><h3 id="下界通配符（表示-T-及其父类）"><a href="#下界通配符（表示-T-及其父类）" class="headerlink" title="下界通配符&lt;? super T&gt;（表示 T 及其父类）"></a>下界通配符<code>&lt;? super T&gt;</code>（表示 T 及其父类）</h3><p>特性：可写（写入 T 及其子类的元素是安全的），但读取受限（读取的元素只能视为 <code>Object</code> 类型）。适用于** “需要向泛型容器中写入元素，且元素类型是 T 的子类型” **的场景（如添加元素到容器）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向列表中添加整数（列表类型可以是 Integer 的父类：Number、Object 等）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addIntegers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>); <span class="comment">// 写入 Integer 及其子类（安全，因为父类容器可接收子类对象）</span></span><br><span class="line">    list.add(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// Integer num = list.get(0); // 编译报错：读取的元素只能视为 Object，因为不清楚是哪个父类，而Object是顶级父类，所以可以用Object接受</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：可接收 List&lt;Integer&gt;、List&lt;Number&gt;、List&lt;Object&gt;</span></span><br><span class="line">addIntegers(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">addIntegers(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;());</span><br><span class="line">addIntegers(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;());</span><br></pre></td></tr></table></figure><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><ul><li><strong>Producer Extends</strong>：如果泛型容器是 “生产者”（主要用于读取元素），使用 <code>&lt;? extends T&gt;</code>（如 <code>List&lt;? extends Number&gt;</code> 生产 Number 类型元素）。</li><li><strong>Consumer Super</strong>：如果泛型容器是 “消费者”（主要用于写入元素），使用 <code>&lt;? super T&gt;</code>（如 <code>List&lt;? super Integer&gt;</code> 消费 Integer 类型元素）。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>泛型在集合框架（List，Map，Set）和主流框架（Spring，Mybatis）中的频繁出现证明其重要性，所以学会使用泛型还是很重要的。</p><p>这篇博客先写到这里，感谢豆包。欢迎评论区指正，我也会继续更新，欢迎收藏<a href="https://withdong02.top/">我的网站</a>。我的眼皮要闭上了😑</p><p>参考文章</p><p><a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客</a></p><p><a href="https://www.wikiwand.com/zh/articles/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型编程 - Wikiwand</a></p><p><a href="https://www.runoob.com/java/java-generics.html">Java 泛型 | 菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/09/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/09/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正则表达式（regular expression），常简写为regex，用简单字符串来描述、匹配文中全部匹配指定格式的字符串。人话讲就是根据一些规则制定一个字符串，然后你可以用这个字符串来筛选满足规则的字符串。许多程序设计语言都支持用正则表达式操作字符串，这里主要介绍正则表达式在Java中的运用。</p><p>不同编程语言的正则表达式引擎有所不同，这里提供一个<a href="https://deerchao.cn/tutorials/regex/diffs.html">链接</a>，里面详细介绍了不同语言对各种特性的支持程度。</p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>先说明一下<code>\</code>的使用。</p><p>在Java普通字符串中，反斜杠<code>\</code>本身就是转义字符，比如<code>\n</code>被转义为”换行符”，又比如<code>\\</code>被转义为<code>\</code>。而正则表达式也有自己的语法，它也使用反斜杠作为转义字符，比如<code>\d</code>表示“匹配一个数字”。</p><p>那么二者结合起来呢🧐。以<code>&quot;\\d&quot;</code>为例。编译器看到字符串<code>&quot;\\d&quot;</code>会根据字符串规则将其转换为两个字符，一个<code>\</code>，一个<code>d</code>。接下来正则表达式引擎会对其进行解析，最终生效的正则模式就是<code>\d</code>。可以这样理解：<strong>正则表达式需要 <code>\d</code> 来匹配数字。但在Java字符串里，一个 <code>\</code> 需要写成 <code>\\</code>。所以，要把正则的 <code>\d</code> 放到Java字符串里，就变成了 <code>\\d</code>。</strong></p><p>到底需不需要两个<code>\\</code>，idea会给你答案。</p><p><code>java.util.regex</code>包是Java标准库中用于支持正则表达式操作的包，主要涉及到<code>Pattern</code>和<code>Matcher</code>这两个类的操作。这里有个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;java\\d&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;java1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="string">&quot;javaBad&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(pattern);</span><br><span class="line"></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text1);</span><br><span class="line">System.out.println(m.matches());<span class="comment">//true</span></span><br><span class="line">m = p.matcher(text2);</span><br><span class="line">System.out.println(m.matches());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>先调用<code>Pattern</code>类的静态方法<code>compile</code>（参数为正则表达式）生成一个实例对象，通过调用该对象的<code>matcher</code>方法（参数为待匹配文本）生成一个<code>Matcher</code>实例。接下来就有很多方法供你选择，这里我调用的是<code>matches</code>方法来输出布尔值，在例子中体现为字符串Java后面能否匹配上数字。<code>Matcher</code>类里还有个<code>find</code>方法也很常见，下文会提到。</p><h2 id="匹配规则详解"><a href="#匹配规则详解" class="headerlink" title="匹配规则详解"></a>匹配规则详解</h2><h3 id="简单匹配"><a href="#简单匹配" class="headerlink" title="简单匹配"></a>简单匹配</h3><p>为方便演示，接下来的示例代码使用<code>String</code>类的<code>matches</code>方法，该方法底层原理仍然是<code>Pattern</code>和<code>Matcher</code>这两个类的使用，后面有详细说明。下面示例参考<a href="https://liaoxuefeng.com/books/java/reg-exp/match-rules/index.html">廖雪峰</a>和<a href="https://www.runoob.com/java/java-regular-expressions.html">菜鸟教程</a>。</p><p><strong>匹配任意字符：</strong><code>.</code>可以匹配除<code>\r\n</code>之外的任何单个字符。如<code>a.c</code>可以匹配<code>abc</code>但不能匹配<code>abbc</code>和<code>ac</code></p><p><strong>匹配数字：</strong><code>\d</code>匹配 0~9 的数字，同样只匹配一个字符。<strong>匹配非数字：</strong><code>\D</code>匹配非数字。</p><p><strong>匹配常用字符：</strong><code>\w</code>可以匹配一个字母、数字或下划线</p><p><strong>匹配空格字符：</strong><code>\s</code>可以匹配任何空白字符，包括空格、制表符、换页符等。与<code>[\f\n\r\t\v]</code>等效。<code>\W</code>和<code>\S</code>和<code>\D</code>同样是反着来的。</p><p><strong>重复匹配：</strong></p><p><code>*</code>可以匹配任意个字符，包括0个字符。</p><p><code>+</code>可以匹配至少一个字符。比如<code>A\d+</code>可以匹配<code>A11111</code>和<code>A0</code>。但不能匹配<code>A</code>,因为至少一个字符。</p><p><code>?</code>可以匹配0个或一个字符。</p><p>如果想精确指定n个字符，使用<code>&#123;n&#125;</code>，比如<code>A\d&#123;3&#125;</code>可以匹配到<code>A123</code>。指定匹配n~m个字符，用<code>&#123;n,m&#125;</code>， 例如<code>A\d&#123;3,5&#125;</code>可以精确匹配<code>A123</code> <code>A1234</code> <code>A12345</code>。<code>&#123;n,&#125;</code>表示可以匹配至少n个字符。m和n为非负整数，其中n &lt;&#x3D; m。再举一个例子:<code>o&#123;2&#125;</code>和Bob中的一个o不匹配，而匹配food中的两个o。<strong>不同表达式可能是等效的，比如<code>o&#123;0,1&#125;</code>和<code>o?</code></strong></p><p>来个综合点的例子：假如电话号码规则如下:3<del>4位数字表示区位，7</del>8位数字表示电话，中间用<code>-</code>连接。答案：<code>\\d&#123;3,4&#125;-\\d&#123;7,8&#125;</code>。对于连字符<code>-</code>，一般情况下只是一个普通字符，不需要进行转义，当然写上两个反斜杠也是对的，idea会给出提示移除多余的反斜杠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;3,4&#125;-\\d&#123;7,8&#125;&quot;</span>;<span class="comment">//不知道需不需要写\？idea会给你的答案</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;0123-123456&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="string">&quot;010-1234567&quot;</span>;</span><br><span class="line">System.out.println(text1.matches(pattern));<span class="comment">//false</span></span><br><span class="line">System.out.println(text2.matches(pattern));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="复杂匹配："><a href="#复杂匹配：" class="headerlink" title="复杂匹配："></a>复杂匹配：</h3><p><strong>匹配开头和结尾：</strong><code>^</code>匹配输入字符串开始的位置，<code>$</code>匹配输入字符串结束的位置。他们俩的作用是将匹配过程限制在整个字符串上，避免了在子串中成功匹配的情况。其实<code>matches()</code>方法的行为已经隐含了<code>^...$</code>锚点的效果，而<code>find()</code>方法则没有。matches方法尝试将整个输入序列与模式匹配，而find方法会在输入序列中查找下一个与模式匹配的子序列。仔细品味这两个方法的名字，你也许会理解。</p><p><strong>匹配指定范围：</strong><code>[xyz]</code>匹配包含的任一字符，比如<code>[abc]</code>匹配<code>plain</code>中的 a。<code>[a-z]</code></p><p>匹配 a 到 z 范围内的任何小写字母。<code>[^a-z]</code>匹配任何不在 a 到 z 范围内的字符，取补集的意思，和前面的<code>\b</code>，<code>\B</code>类似。<code>[0-9]</code>和<code>[A-Z]</code>同样理解。</p><p>如果要匹配6位十六进制数，可以这样写：<code>[0-9a-fA-F]&#123;6&#125;</code></p><p><strong>或规则匹配：</strong><code>AB|CD</code>表示可以匹配 AB 或 CD。<code>(z|f)ood</code>匹配 zood 或 food，当然这个正则表达式也可以写成<code>[zf]ood</code>。</p><p>**分组匹配：**字面意思，通过()将表达式分组处理，可以配合<code>Matcher</code>类的<code>group</code>方法使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">System.out.println(g1); <span class="comment">// 010</span></span><br><span class="line">System.out.println(g2); <span class="comment">// 12345678</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非贪婪匹配：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察这个例子，第二个输出空字符串，输出没问题，因为<code>\d+</code>可以匹配到后面的数字。正则表达式默认使用贪婪匹配，以<code>\d+</code>为例，后面有多少数字就匹配多少（只要连续），这样<code>0*</code>就匹配到空字符串。如果想让<code>\d+</code>少匹配，可以写成<code>(\\d+?)(0*)</code>，<code>?</code>表示非贪婪匹配，这样输出就变成了<code>&quot;123&quot; &quot;0000&quot;</code>。</p><p>不能简单的把非贪婪匹配认为最少匹配，觉得输出应该是<code>1</code>和<code>230000</code>。非贪婪匹配是在保证后面表达式都能匹配上的前提下尽量少匹配。引擎保证的是整体成功优先，我认为可以是一种平衡吧，这里不做过多解释，因为更深层的原理我也不懂。</p><p>这里的<code>?</code>和前面提到的<code>?</code>不一样。<code>(\d??)(9*)</code>，<code>\d?</code>表示匹配0个或1个数字，后面的<code>?</code>表示非贪婪匹配。如果给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别为<code>&quot;&quot;</code> <code>&quot;9999&quot;</code></p><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>**匹配邮箱：**这里假设字符@前可以出现数字、英文字母、下划线和中划线，字符@后是域名格式，长度不限。</p><p>先分析邮箱名称部分，只能出现数字、英文字母和下划线、中划线，那么可以这样写<code>[0-9a-zA-Z_-]</code>，也可以选择<code>\w</code>，这里我选择第二种。又因为不止一个字符，所以加个<code>+</code>。变成<code>\w+</code></p><p>然后分析域名部分，域名一般是<code>weixin.qq.com</code>这种类型，也就是<code>**.**.**</code>。可以以第一个英文句点为分界线将其拆解为两部分。一部分是<code>**</code>一部分是<code>.**</code>的复制粘贴。第一部分依然可以这样写<code>\w+</code>，一个<code>.**</code>这样写<code>\.\w+</code>，多个<code>.**</code>这样写<code>(.\w+)+</code>。</p><p>经过分析，答案就是<code>\w+@\w+(.\w+)+</code>，放到java中，需要写成<code>\\w+@\\w+(.\\w+)+</code>，还是那句话：到底需不需要写反斜杠，idea会给你答案。</p><p>如果你在浏览器搜索“正则表达式邮箱匹配”，你可能会得到很多答案，当你不确定时，多去尝试。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><code>Matcher</code>类除了提到的<code>matches</code>方法和<code>find</code>方法，还有<code>start``replaceAll</code>等，可以点击<a href="https://www.runoob.com/java/java-regular-expressions.html">链接</a>了解更多。这里我想介绍一下<code>Pattern</code>和<code>Matcher</code>这两个类出现的其他地方，比如上文提到的<code>String.matches()</code>方法。</p><p>为什么说<code>String.matches()</code>方法底层原理仍然是<code>Pattern</code>和<code>Matcher</code>这两个类的使用。ctrl+鼠标左键点开方法源码即可发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Pattern.matches(regex, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用的是<code>Pattern</code>类的静态方法<code>matches</code>，同时传进去两个参数，一个正则表达式，一个待匹配字符串。接着点进去matches方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex, CharSequence input)</span> &#123;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(input);</span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会发现这跟之前的示例代码没啥两样，只是<code>compile</code>和<code>matcher</code>这两个方法的参数不再是字符串常量，而是传进来的参数<code>regex</code>和<code>input</code>。</p><p>再说一个例子，就是<code>String.split()</code>方法。简单说一下：这个方法最终调用的是<code>String</code>类的<code>private String[] split(String regex, int limit, boolean withDelimiters) &#123;...&#125;</code>这个方法，可以看到传进去一个正则表达式作为参数，这个方法的最后几行代码是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="keyword">return</span> withDelimiters</span><br><span class="line">? pattern.splitWithDelimiters(<span class="built_in">this</span>, limit)</span><br><span class="line">: pattern.split(<span class="built_in">this</span>, limit);</span><br></pre></td></tr></table></figure><p>根据参数<code>withDelimiters</code>的布尔值来确定调用对象pattern的哪个方法，其实这两个方法最终调用的还是一个方法，兜兜转转还是回到了<code>Pattern</code>类和<code>Matcher</code>类。</p><p>这篇博客就到这里，错误不可避免，欢迎指正。我会持续更新，欢迎收藏<a href="https://withdong02.top/">我的网站</a>。</p><p>参考文章：</p><ul><li><a href="https://liaoxuefeng.com/books/java/reg-exp/complex-match/index.html">复杂匹配规则 - Java教程 - 廖雪峰的官方网站</a></li><li><a href="https://www.runoob.com/java/java-regular-expressions.html">Java 正则表达式 | 菜鸟教程</a></li><li><a href="https://blog.csdn.net/weixin_43860260/article/details/91417485">Java 正则表达式的用法和实例-CSDN博客</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2025/08/10/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2025/08/10/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在<code>spring</code>项目中，只需要写个<code>@Service</code>或者<code>@Component</code>，然后在别的地方用<code>@Autowired</code>声明一个接口变量，<code>Spring</code>就能返回给我们一个实现了该接口的具体对象。这是如何实现的呢？它不可能在编译时就知道加了注解的类与类之间的关系，所以只能是在程序启动<strong>运行时</strong>，Spring动态地发现了这些类，读取了他们的结构，然后创建对象。这背后的技术支撑又是什么？答案就是反射。</p><p>反射是Java提供的一种在<strong>程序运行时</strong></p><ul><li>检查&#x2F;获取类、接口、字段、方法、构造器等结构信息的能力。</li><li>操作&#x2F;调用对象、字段、方法的能力。</li></ul><p>它就像一面镜子，让程序在运行时“照见”自己的结构。</p><h2 id="反射的基石：Class对象"><a href="#反射的基石：Class对象" class="headerlink" title="反射的基石：Class对象"></a>反射的基石：<code>Class</code>对象</h2><p>编译器在编译 Java 源代码时会生成 <code>.class</code> 文件（字节码文件）。当 JVM 需要用到某个类时，它的类加载器会读取并解析对应的 <code>.class</code> 文件，在方法区（或元空间）构建该类的运行时数据结构，同时在堆内存中创建一个代表该类的 <strong><code>java.lang.Class</code> 对象</strong>。每个被加载的类在 JVM 中都有且只有一个对应的 <code>Class</code> 对象（在同一个类加载器命名空间内）。</p><p>这里的<code>Class</code>是一个类的名字，不要和<code>class</code>关键字搞混。</p><p>有三种方法获取<code>Class</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;me&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//法一：通过对象实例</span></span><br><span class="line">Class&lt; ? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; clazz1 = person.getClass();</span><br><span class="line"><span class="comment">//法二：自带属性（基本数据类型也有）</span></span><br><span class="line">Class&lt;Person&gt; clazz2 = Person.class;</span><br><span class="line"><span class="comment">//法三：Class类的静态方法 forName</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;org.myblog.reflection.Person&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下这三种方法泛型的使用：法一使用<code>Class&lt;? extends Person&gt; </code>因为<code>Class</code>对象是在运行时从<code>Person</code>实例获取的，而<code>Person</code>实例的具体类型只能在运行时创建和确定，编译阶段无法判断，所以使用通配符 ，又因为<code>person</code>可能是<code>Person</code>实例，也可能是<code>Person</code>的子类实例，所以最终写成<code>Class&lt; ? extends Person&gt;</code>；法二使用<code>Class&lt;Person&gt;</code>因为编译时已知具体类型；法三使用<code>Class&lt;?&gt;</code>因为通过字符串动态加载类，编译时无法确定具体类型，所以使用通配符。这三个 Class 对象都是同一个（上面也提到了，一个类唯一对应一个 Class 对象）。</p><p><strong>最常用、最灵活的是法三</strong></p><h2 id="反射的核心操作"><a href="#反射的核心操作" class="headerlink" title="反射的核心操作"></a>反射的核心操作</h2><p><code>Person</code>类具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">species</span> <span class="operator">=</span> <span class="string">&quot;Human&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unknown&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;,I&#x27;m &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">celebrateBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        age++;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is now &quot;</span> + age + <span class="string">&quot; years old!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">describeSpecies</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;We are all &quot;</span> + species);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.example.myblog.reflection.Person&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;类名：&quot;</span> + clazz.getName());</span><br><span class="line">System.out.println(<span class="string">&quot;包名：&quot;</span> + clazz.getPackage().getName());</span><br><span class="line">System.out.println(<span class="string">&quot;父类：&quot;</span> + clazz.getSuperclass());</span><br><span class="line">System.out.println(<span class="string">&quot;接口：&quot;</span> + Arrays.toString(clazz.getInterfaces()));</span><br><span class="line">System.out.println(<span class="string">&quot;修饰符：&quot;</span> + Modifier.toString(clazz.getModifiers()));</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名：org.example.myblog.reflection.Person</span><br><span class="line">包名：org.example.myblog.reflection</span><br><span class="line">父类：class java.lang.Object</span><br><span class="line">接口：[]</span><br><span class="line">修饰符：public</span><br></pre></td></tr></table></figure><h3 id="操作字段"><a href="#操作字段" class="headerlink" title="操作字段"></a>操作字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;操作字段+++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : allFields) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;- &quot;</span> + Modifier.toString(f.getModifiers()) + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    f.getType().getSimpleName() + <span class="string">&quot; &quot;</span> + f.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;me&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//访问public字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(nameField.get(me));</span><br><span class="line"><span class="comment">//访问private字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(ageField.get(me));</span><br><span class="line">ageField.set(me, <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改后年龄: &quot;</span> + ageField.get(me));</span><br><span class="line"><span class="comment">//访问static字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">speciesField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;species&quot;</span>);</span><br><span class="line">System.out.println(speciesField.get(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">public</span> String name</span><br><span class="line">- <span class="keyword">private</span> <span class="type">int</span> age</span><br><span class="line">- <span class="keyword">public</span> <span class="keyword">static</span> String species</span><br><span class="line">me</span><br><span class="line"><span class="number">20</span></span><br><span class="line">修改后年龄: <span class="number">18</span></span><br><span class="line">Human</span><br></pre></td></tr></table></figure><p>说明几点：</p><ol><li><p><code>getDeclaredFields()</code>是获取所有字段，并返回一个数组，<code>getField</code>则是根据参数返回指定字段，返回的是<code>Field</code>实例。</p></li><li><p>最后一行<code>speciesField.get(null)</code>传入参数<code>null</code>，因为静态字段是属于这个类的，当然也可以传入对象<code>me</code>。</p></li><li><p><code>ageField.setAccessible(true);</code>这个方法传入参数<code>true</code>表示<strong>屏蔽Java语言的访问检查</strong>。看下面这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : allFields) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> Modifier.isStatic(f.getModifiers()) ? <span class="literal">null</span> : me;</span><br><span class="line">    System.out.println(<span class="string">&quot;  可访问性: &quot;</span> + f.canAccess(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   public String name</span><br><span class="line">   可访问性: true</span><br><span class="line">   private int age</span><br><span class="line">   可访问性: false</span><br><span class="line">   public static String species</span><br><span class="line">   可访问性: true</span><br><span class="line"></span><br><span class="line">​输出如上，`age`是不可访问的，在`setAccessible(true)`后可以访问并修改。否则会报错。</span><br><span class="line"></span><br><span class="line">4. 如果想要访问`private`或其他非`public`字段，必须使用`getDeclaredField()`，**注意里面有`Declared`，这个规律同样适用后面的`Method`和`Constructor`。**</span><br><span class="line"></span><br><span class="line">### 操作方法</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">System.out.println(&quot;\n==== 方法操作 ====&quot;);</span><br><span class="line">Person Dong = new Person(&quot;dong&quot;, 18);</span><br><span class="line">Method[] allMethods = clazz.getDeclaredMethods();</span><br><span class="line">System.out.println(&quot;所有方法:&quot;);</span><br><span class="line">for (Method m : allMethods) &#123;</span><br><span class="line">System.out.println(&quot;- &quot; + m.getName() + &quot;()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 调用public方法</span><br><span class="line">Method greetMethod = clazz.getMethod(&quot;greet&quot;, String.class);</span><br><span class="line">greetMethod.invoke(Dong, &quot;李明&quot;);</span><br><span class="line">// 调用private方法</span><br><span class="line">Method birthdayMethod = clazz.getDeclaredMethod(&quot;celebrateBirthday&quot;);</span><br><span class="line">birthdayMethod.setAccessible(true);</span><br><span class="line">birthdayMethod.invoke(Dong);</span><br><span class="line">System.out.println(&quot;新年龄: &quot; + ageField.get(Dong)); // 验证年龄增加</span><br><span class="line">// 调用static方法</span><br><span class="line">Method speciesMethod = clazz.getMethod(&quot;describeSpecies&quot;);</span><br><span class="line">speciesMethod.invoke(null);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">所有方法:</span><br><span class="line">- celebrateBirthday()</span><br><span class="line">- describeSpecies()</span><br><span class="line">- greet()</span><br><span class="line">Hello 李明,I&#x27;m dong</span><br><span class="line">dong is now 19 years old!</span><br><span class="line">新年龄: 19</span><br><span class="line">We are all Human</span><br></pre></td></tr></table></figure><p>其实和操作字段有很多相似之处，这里说一下<code>invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">greetMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;greet&quot;</span>, String.class);</span><br><span class="line">greetMethod.invoke(Dong, <span class="string">&quot;李明&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>getMethod</code>方法有两个参数，一个是方法名称，一个是参数的<code>class</code>对象</p><p><code>greetMethod</code>方法同样有两个参数，一个是对象实例（如果是静态方法则传入<code>null</code>），一个是传递的参数。这两个方法的参数个数不是固定的(其实是个数组)，这取决于目标方法的参数个数。</p><h3 id="操作构造器"><a href="#操作构造器" class="headerlink" title="操作构造器"></a>操作构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">System.out.println(<span class="string">&quot;所有构造器:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; c : constructors) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;参数数量: &quot;</span> + c.getParameterCount());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用public无参构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; emptyConstructor = clazz.getConstructor();</span><br><span class="line"><span class="type">Person</span> <span class="variable">unknown</span> <span class="operator">=</span> (Person) emptyConstructor.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;无参构造创建: &quot;</span> + unknown.name);</span><br><span class="line"><span class="comment">// 使用public带参构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; paramConstructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Person</span> <span class="variable">sarah</span> <span class="operator">=</span> (Person) paramConstructor.newInstance(<span class="string">&quot;Sarah&quot;</span>, <span class="number">28</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;带参构造创建: &quot;</span> + sarah.name + <span class="string">&quot;, &quot;</span> + ageField.get(sarah));</span><br><span class="line"><span class="comment">// 使用private构造器创建对象</span></span><br><span class="line">Constructor&lt;?&gt; privateConstructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">privateConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">secret</span> <span class="operator">=</span> (Person) privateConstructor.newInstance(<span class="string">&quot;Secret&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;私有构造创建: &quot;</span> + secret.name + <span class="string">&quot;, &quot;</span> + ageField.get(secret));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">所有构造器:</span><br><span class="line">参数数量: 1</span><br><span class="line">参数数量: 2</span><br><span class="line">参数数量: 0</span><br><span class="line">无参构造创建: Unknown</span><br><span class="line">带参构造创建: Sarah, 28</span><br><span class="line">私有构造创建: Secret, 18</span><br></pre></td></tr></table></figure><p>经过前面叙述，这里的相关方法也是很好理解，<code>getConstructor</code>方法的参数取决于你拿到的构造器的参数（其实也是个数组）。</p><p><code>newInstance()</code>方法可以根据你拿到的构造器来创建该构造器所在类的实例，参数同上理解。例子中是直接强转类型了，如果<code>clazz</code>是用法二得到的，也可以使用<code>cast</code>方法进行类型转换。一般来说这个方法创建的实例用<code>Object</code>来接收，因为创建的对象是在运行时动态生成的，编译阶段无法知道。<strong>建议使用反射直接调用和操作对象的方法和字段，而不是先进行类型转换，毕竟如果在编写阶段已经明确了要转换的类型，那么直接显示地调用更合适，而不必依赖于反射。反射的真正价值在于处理编译时未知的类型，从而编写更具有通用性的代码。</strong></p><p>示例里用<code>Constructor&lt;?&gt;</code>接收<code>clazz.getConstructor()</code>创建的实例是因为<code>clazz</code>的创建就使用的是通配符。如果在创建时指定类，那便可以指定泛型参数，相当于构造器就知道自己要构造的对象是什么类型了。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>上述内容只是反射部分的冰山一角，我已经尽我所能把这“一角”讲述清楚。</p><p>反射很强，它能提供运行时动态操作类和对象的能力，是很多框架的基石，但同时它也带来了很多问题，性能开销大、代码可读性差等等。在日常开发中，程序员还是会优先选择直接调用、接口、设计模式等更清晰、高效的方式。</p><p>有机会我也会更新一个与反射有关的实战案例，欢迎收藏我的网站。</p><p>参考文章：</p><ul><li><p><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">大白话说Java反射：入门、使用、原理 - 陈树义 - 博客园</a></p></li><li><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遇到的奇葩BUG</title>
      <link href="/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/"/>
      <url>/2025/08/02/%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E8%91%A9BUG/</url>
      
        <content type="html"><![CDATA[<p>此篇博客记录我学习过程中遇到的奇葩BUG</p><h2 id="SpringBoot项目启动失败"><a href="#SpringBoot项目启动失败" class="headerlink" title="SpringBoot项目启动失败"></a><code>SpringBoot</code>项目启动失败</h2><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250801212248493.png" alt="image-20250801212248493"></p><p>如上图，<code>SpringBoot</code>项目启动失败。</p><p>虽然说是端口占用，但我执行相关命令后没有任何输出，修改启动端口不行，尝试了很多办法都未成功，那只好使出我的终极大招：重启idea。还是不行。幸好我还有终极终极大招：重启电脑。嘿，你猜怎么着，成了！🤣</p><h2 id="接口测试报错getaddrinfo-ENOTFOUND-https"><a href="#接口测试报错getaddrinfo-ENOTFOUND-https" class="headerlink" title="接口测试报错getaddrinfo ENOTFOUND https"></a>接口测试报错<code>getaddrinfo ENOTFOUND https</code></h2><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250827154544934.png" alt="image-20250827154544934"></p><p>一次简单的接口测试，出现报错<code>getaddrinfo ENOTFOUND https</code>，搜索后得到答案：这通常意味着应用程序无法解析主机名或域名。这可能是由于DNS配置问题、网络连接问题或拼写错误等原因导致的。前两个果断排除，开始以为参数错，但一想那不应该试着错误，后来想可能域名错，但也没找到错误。最后发现是<code>https:</code>后面多了个空格。😑</p>]]></content>
      
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化与反序列化</title>
      <link href="/2025/07/07/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/07/07/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><p>序列化，人话讲就是将对象转换为字节序列（也可以是JSON、XML等文本格式），反序列化就是把这个过程倒置。</p><p>下面是维基百科关于序列化的介绍</p><blockquote><p><strong>序列化</strong>（serialization）在<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">计算机科学</a>的资料处理中，是指将<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>或<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%B8)">对象</a>状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%BB%84">字节</a>的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是<strong>反序列化</strong>（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>对于Java这种面向对象的编程语言来说，是对实例化后的对象进行序列化，而对于C++这种半面向对象的编程语言来说，序列化的目标不仅有对象（class）还有数据结构（struct）</p><h2 id="序列化的使用场景"><a href="#序列化的使用场景" class="headerlink" title="序列化的使用场景"></a>序列化的使用场景</h2><ol><li><p>数据存储：比如序列化可以将存储在 JVM 堆区中的对象转换成字节序列，从而实现持久化。</p></li><li><p>网络通信：将对象转换为字节序列方便其在网络中进行传递和接收。</p></li></ol><h2 id="使用Java实现序列化"><a href="#使用Java实现序列化" class="headerlink" title="使用Java实现序列化"></a>使用Java实现序列化</h2><p>以 JDK 自带序列化方法为例，实现<code>java.io.Serializable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        cat.setAge(<span class="number">2</span>);</span><br><span class="line">        cat.setBirth(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//使用ObjectOutputStream将cat对象序列化并存入test1.txt文件中</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream)) &#123;</span><br><span class="line">            objectOutputStream.writeObject(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">deserializeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用ObjectInputStream对test.txt文件读取并反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.txt&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream)) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) objectInputStream.readObject();</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=2, name=tom, birth=Fri Jul 04 21:37:13 CST 2035)</span><br></pre></td></tr></table></figure><p>接下来让我们走进<code>Serializable</code>的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错，<code>Serializable</code>接口中没有任何方法和字段，它的作用仅仅是告诉JVM：实现该接口的类可以被序列化，</p><p>其实除了实现<code>Serializable</code>接口外，还有一个选择就是实现<code>Externalizable</code>接口（该接口是<code>Serializable</code>的子接口），不过需要重写两个方法，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeObject(birth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        birth = (Date) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化代码一样，最终结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat(age=0, name=tom, birth=Fri Jul 04 21:43:23 CST 2025)</span><br></pre></td></tr></table></figure><p><code>writeExternal</code>和<code>readExternal</code>可以自定义哪些字段需要序列化，我这个例子中就没有对<code>age</code>进行操作，在反序列化后它被赋初值0。需要注意的是</p><blockquote><p>The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.</p></blockquote><p>翻译过来意思就是这两个方法应该用相同的顺序和相同的类型对字段进行读写，相同的顺序容易理解，相同的类型意思就是在<code>readExternal</code>中强转的目标类型必须和<code>writeExternal</code>原类型保持一致。在实现<code>Externalizable</code>接口时，还有一点需要注意的是序列化对象中必须提供无参构造，以Cat类为例,当我加入一个有参构造覆盖默认无参构造后，序列化正常运行，反序列化出现报错</p><p><img src="https://dongimagehost-1356670526.cos.ap-nanjing.myqcloud.com/2025/07/image-20250705112136780.png" alt="image-20250705112136780"></p><p><strong>关于序列化有几点需要注意：</strong></p><ol><li><p>只有实现该接口的类才可以被序列化。</p></li><li><p>可序列化类的所有子类是可以被序列化的。不可序列化类的子类型可以被序列化。</p></li><li><p>如果不想对某个变量序列化，可以用<code>transient</code>关键字修饰，它只能修饰变量，不能修饰类和方法。<code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</p></li><li><p>序列化运行时会为每个可序列化类分配一个版本号<code>serialVersionUID</code>该版本号在序列化机制中用于验证类的版本是否一致，如果反序列化时的UID和原来序列化的UID不同，则会抛出<code>InvalidClassException</code>。</p><p>这个字段可以手动显示声明，也可以自动生成。如果显示声明，这个字段必须是<code>static</code> <code>final</code>且类型为<code>long</code>的。如果该字段未被显示声明，JVM会根据该类的结构自动生成一个<code>serialVersionUID</code>，枚举类的<code>serialVersionUID</code>会被定义为0L。</p><p>官方强烈建议除了枚举类型以外的所有可序列化类显示声明<code>serialVersionUID</code>值，因为生成算法对类的细节非常敏感（如方法、字段等的变化都会导致<code>serialVersionUID</code>改变），从而导致兼容性问题。显式设置 <code>serialVersionUID </code>可以确保在类发生非兼容更改时由开发者主动决定是否更新 UID，而不是因为类结构微小变化而导致反序列化失败。同时官方建议使用private来声明<code>serialVersionUID</code>，因为该字段不会被子类继承使用，因此没必要设置为<code>public</code>或<code>protected</code>。下面是一个完整的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serial</span><span class="comment">//Java14后建议添加</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>这时小明举手说：老师老师，如果<code>serialVersionUID</code>被<code>static</code>修饰，那他就属于这个类，而不属于实例化后的对象了，那怎么将这个字段序列化呢？老师说：好问题，<del>我也不知道。</del> 序列化保存的是对象的状态，也就是实例变量的值，然而<code>serialVersionUID</code>是一个特例，它本身确实不作为对象状态被序列化，但它的值被序列化机制特殊处理了。屏幕前的你明白了吗，反正我还是有点糊涂，我觉得把它视为一个特例就好了，要真正弄懂怕是要搞明白JVM，那要很久以后了。</p></li></ol><h2 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h2><p>这里我推荐观看<a href="https://5i1encee.top/">5i1encee</a>的相关博客，关于反序列化漏洞我简要介绍一下。</p><p>当攻击者通过构造恶意输入，让反序列化产生非预期的的对象，那么在反序列化这个过程中就可能执行恶意代码。已经有多个版本的库或框架被发现存在反序列化漏洞，如<code>Apache Commons Collections</code> 。借用<a href="https://www.zhihu.com/question/37562657/answer/1916596031">一位大哥</a>的例子来简单说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerabilityTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>MyObject</code>这个类中，自定义了<code>readObject</code>这个方法，相当于可以自己决定对哪些字段反序列化。在<code>readObject</code>这个方法里通过调用<code>defaultReadObject</code>来实现默认的反序列化机制。之后执行了名为<code>calc</code>的系统命令，这是<code>Windows</code>下启动计算器的命令。当我进行反序列化操作时，电脑上的计算器也随之启动。实际上，Java 反序列化漏洞产生的原因大多数是因为反序列化时没有进行校验，或者有些校验使用黑名单方式又被绕过，最终使得包含恶意代码的序列化对象在服务器端被反序列化执行。</p><h2 id="其他序列化协议"><a href="#其他序列化协议" class="headerlink" title="其他序列化协议"></a>其他序列化协议</h2><p>上述有关代码的举例均是 JDK 自带的序列化协议，但它在开发中很少被使用，主要原因如下：</p><ol><li>严重的安全风险：正如例子中提到的<code>readObject</code>方法，攻击者可构造恶意序列化数据触发任意代码执行</li><li>跨语言兼容性差：该协议序列化后的二进制数据只能被 Java 程序识别，无法与其他语言交互，多语言协作困难。</li><li>性能低下：序列化后的二进制数据体积远大于 JSON 或其他二进制协议。同时因为需要反射和递归处理对象图，导致速度较慢。</li></ol><p>常用的序列化协议有Hessian、Kryo、 Protobuf、 ProtoStuff 等，这些都是基于二进制的序列化协议。SpringBoot 项目中也可以集成 Jackson、Fastjson 等将对象序列化为JSON格式的库。</p><p>第一篇博客先写到这里，个人理解难免有偏差，欢迎评论区指正。我以后也会继续更新，欢迎收藏<a href="https://withdong02.top/">我的网站</a>。</p><p>参考文章：</p><ul><li><a href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解 | JavaGuide</a></li><li><a href="https://www.zhihu.com/question/37562657/answer/1916596031">(6 封私信 &#x2F; 70 条消息) Java反序列化安全漏洞怎么回事? - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
